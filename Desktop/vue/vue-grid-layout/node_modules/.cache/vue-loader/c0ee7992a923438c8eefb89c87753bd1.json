{"remainingRequest":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\components\\GridItem.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\components\\GridItem.vue","mtime":1620240796182},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\r\nimport {\r\n  setTopLeft,\r\n  setTopRight,\r\n  setTransformRtl,\r\n  setTransform,\r\n} from \"@/helpers/utils\";\r\nimport { getControlPosition, createCoreData } from \"@/helpers/draggableUtils\";\r\nimport { getColsFromBreakpoint } from \"@/helpers/responsiveUtils\";\r\nimport { getDocumentDir } from \"@/helpers/DOM\";\r\n//    var eventBus = require('./eventBus');\r\n\r\nimport \"@interactjs/auto-start\";\r\nimport \"@interactjs/actions/drag\";\r\nimport \"@interactjs/actions/resize\";\r\nimport \"@interactjs/modifiers\";\r\nimport \"@interactjs/dev-tools\";\r\nimport interact from \"@interactjs/interact\";\r\n\r\nexport default {\r\n  name: \"GridItem\",\r\n  props: {\r\n    /*cols: {\r\n             type: Number,\r\n             required: true\r\n             },*/\r\n    /*containerWidth: {\r\n             type: Number,\r\n             required: true\r\n\r\n             },\r\n             rowHeight: {\r\n             type: Number,\r\n             required: true\r\n             },\r\n             margin: {\r\n             type: Array,\r\n             required: true\r\n             },\r\n             maxRows: {\r\n             type: Number,\r\n             required: true\r\n             },*/\r\n    isDraggable: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: null,\r\n    },\r\n    isResizable: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: null,\r\n    },\r\n    /*useCssTransforms: {\r\n             type: Boolean,\r\n             required: true\r\n             },\r\n             */\r\n    static: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n    minH: {\r\n      type: Number,\r\n      required: false,\r\n      default: 1,\r\n    },\r\n    minW: {\r\n      type: Number,\r\n      required: false,\r\n      default: 1,\r\n    },\r\n    maxH: {\r\n      type: Number,\r\n      required: false,\r\n      default: Infinity,\r\n    },\r\n    maxW: {\r\n      type: Number,\r\n      required: false,\r\n      default: Infinity,\r\n    },\r\n    x: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    y: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    w: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    h: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    i: {\r\n      required: true,\r\n    },\r\n    dragIgnoreFrom: {\r\n      type: String,\r\n      required: false,\r\n      default: \"a, button\",\r\n    },\r\n    dragAllowFrom: {\r\n      type: String,\r\n      required: false,\r\n      default: null,\r\n    },\r\n    resizeIgnoreFrom: {\r\n      type: String,\r\n      required: false,\r\n      default: \"a, button\",\r\n    },\r\n    preserveAspectRatio: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n  },\r\n  inject: [\"eventBus\", \"layout\"],\r\n  data: function() {\r\n    return {\r\n      cols: 1,\r\n      containerWidth: 100,\r\n      rowHeight: 30,\r\n      margin: [10, 10],\r\n      maxRows: Infinity,\r\n      draggable: null,\r\n      resizable: null,\r\n      useCssTransforms: true,\r\n      useStyleCursor: true,\r\n\r\n      isDragging: false,\r\n      dragging: null,\r\n      isResizing: false,\r\n      resizing: null,\r\n      lastX: NaN,\r\n      lastY: NaN,\r\n      lastW: NaN,\r\n      lastH: NaN,\r\n      style: {},\r\n      rtl: false,\r\n\r\n      dragEventSet: false,\r\n      resizeEventSet: false,\r\n\r\n      previousW: null,\r\n      previousH: null,\r\n      previousX: null,\r\n      previousY: null,\r\n      innerX: this.x,\r\n      innerY: this.y,\r\n      innerW: this.w,\r\n      innerH: this.h,\r\n    };\r\n  },\r\n  created() {\r\n    let self = this;\r\n\r\n    // Accessible refernces of functions for removing in beforeDestroy\r\n    self.updateWidthHandler = function(width) {\r\n      self.updateWidth(width);\r\n    };\r\n\r\n    self.compactHandler = function(layout) {\r\n      self.compact(layout);\r\n    };\r\n\r\n    self.setDraggableHandler = function(isDraggable) {\r\n      if (self.isDraggable === null) {\r\n        self.draggable = isDraggable;\r\n      }\r\n    };\r\n\r\n    self.setResizableHandler = function(isResizable) {\r\n      if (self.isResizable === null) {\r\n        self.resizable = isResizable;\r\n      }\r\n    };\r\n\r\n    self.setRowHeightHandler = function(rowHeight) {\r\n      self.rowHeight = rowHeight;\r\n    };\r\n\r\n    self.setMaxRowsHandler = function(maxRows) {\r\n      self.maxRows = maxRows;\r\n    };\r\n\r\n    self.directionchangeHandler = () => {\r\n      this.rtl = getDocumentDir() === \"rtl\";\r\n      this.compact();\r\n    };\r\n\r\n    self.setColNum = (colNum) => {\r\n      self.cols = parseInt(colNum);\r\n    };\r\n\r\n    this.eventBus.$on(\"updateWidth\", self.updateWidthHandler);\r\n    this.eventBus.$on(\"compact\", self.compactHandler);\r\n    this.eventBus.$on(\"setDraggable\", self.setDraggableHandler);\r\n    this.eventBus.$on(\"setResizable\", self.setResizableHandler);\r\n    this.eventBus.$on(\"setRowHeight\", self.setRowHeightHandler);\r\n    this.eventBus.$on(\"setMaxRows\", self.setMaxRowsHandler);\r\n    this.eventBus.$on(\"directionchange\", self.directionchangeHandler);\r\n    this.eventBus.$on(\"setColNum\", self.setColNum);\r\n\r\n    this.rtl = getDocumentDir() === \"rtl\";\r\n  },\r\n  beforeDestroy: function() {\r\n    let self = this;\r\n    //Remove listeners\r\n    this.eventBus.$off(\"updateWidth\", self.updateWidthHandler);\r\n    this.eventBus.$off(\"compact\", self.compactHandler);\r\n    this.eventBus.$off(\"setDraggable\", self.setDraggableHandler);\r\n    this.eventBus.$off(\"setResizable\", self.setResizableHandler);\r\n    this.eventBus.$off(\"setRowHeight\", self.setRowHeightHandler);\r\n    this.eventBus.$off(\"setMaxRows\", self.setMaxRowsHandler);\r\n    this.eventBus.$off(\"directionchange\", self.directionchangeHandler);\r\n    this.eventBus.$off(\"setColNum\", self.setColNum);\r\n    if (this.interactObj) {\r\n      this.interactObj.unset(); // destroy interact intance\r\n    }\r\n  },\r\n  mounted: function() {\r\n    if (this.layout.responsive && this.layout.lastBreakpoint) {\r\n      this.cols = getColsFromBreakpoint(\r\n        this.layout.lastBreakpoint,\r\n        this.layout.cols\r\n      );\r\n    } else {\r\n      this.cols = this.layout.colNum;\r\n    }\r\n    this.rowHeight = this.layout.rowHeight;\r\n    this.containerWidth = this.layout.width !== null ? this.layout.width : 100;\r\n    this.margin =\r\n      this.layout.margin !== undefined ? this.layout.margin : [10, 10];\r\n    this.maxRows = this.layout.maxRows;\r\n\r\n    if (this.isDraggable === null) {\r\n      this.draggable = this.layout.isDraggable;\r\n    } else {\r\n      this.draggable = this.isDraggable;\r\n    }\r\n    if (this.isResizable === null) {\r\n      this.resizable = this.layout.isResizable;\r\n    } else {\r\n      this.resizable = this.isResizable;\r\n    }\r\n    this.useCssTransforms = this.layout.useCssTransforms;\r\n    this.useStyleCursor = this.layout.useStyleCursor;\r\n    this.createStyle();\r\n  },\r\n  watch: {\r\n    isDraggable: function() {\r\n      this.draggable = this.isDraggable;\r\n    },\r\n    static: function() {\r\n      this.tryMakeDraggable();\r\n      this.tryMakeResizable();\r\n    },\r\n    draggable: function() {\r\n      this.tryMakeDraggable();\r\n    },\r\n    isResizable: function() {\r\n      this.resizable = this.isResizable;\r\n    },\r\n    resizable: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    rowHeight: function() {\r\n      this.createStyle();\r\n      this.emitContainerResized();\r\n    },\r\n    cols: function() {\r\n      this.tryMakeResizable();\r\n      this.createStyle();\r\n      this.emitContainerResized();\r\n    },\r\n    containerWidth: function() {\r\n      this.tryMakeResizable();\r\n      this.createStyle();\r\n      this.emitContainerResized();\r\n    },\r\n    x: function(newVal) {\r\n      this.innerX = newVal;\r\n      this.createStyle();\r\n    },\r\n    y: function(newVal) {\r\n      this.innerY = newVal;\r\n      this.createStyle();\r\n    },\r\n    h: function(newVal) {\r\n      this.innerH = newVal;\r\n      this.createStyle();\r\n      // this.emitContainerResized();\r\n    },\r\n    w: function(newVal) {\r\n      this.innerW = newVal;\r\n      this.createStyle();\r\n      // this.emitContainerResized();\r\n    },\r\n    renderRtl: function() {\r\n      // console.log(\"### renderRtl\");\r\n      this.tryMakeResizable();\r\n      this.createStyle();\r\n    },\r\n    minH: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    maxH: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    minW: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    maxW: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    \"$parent.margin\": function(margin) {\r\n      if (\r\n        !margin ||\r\n        (margin[0] == this.margin[0] && margin[1] == this.margin[1])\r\n      ) {\r\n        return;\r\n      }\r\n      this.margin = margin.map((m) => Number(m));\r\n      this.createStyle();\r\n      this.emitContainerResized();\r\n    },\r\n  },\r\n  computed: {\r\n    classObj() {\r\n      return {\r\n        \"vue-resizable\": this.resizableAndNotStatic,\r\n        static: this.static,\r\n        resizing: this.isResizing,\r\n        \"vue-draggable-dragging\": this.isDragging,\r\n        cssTransforms: this.useCssTransforms,\r\n        \"render-rtl\": this.renderRtl,\r\n        \"disable-userselect\": this.isDragging,\r\n        \"no-touch\": this.isAndroid && this.draggableOrResizableAndNotStatic,\r\n      };\r\n    },\r\n    resizableAndNotStatic() {\r\n      return this.resizable && !this.static;\r\n    },\r\n    draggableOrResizableAndNotStatic() {\r\n      return (this.draggable || this.resizable) && !this.static;\r\n    },\r\n    isAndroid() {\r\n      return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\r\n    },\r\n    renderRtl() {\r\n      return this.layout.isMirrored ? !this.rtl : this.rtl;\r\n    },\r\n    resizableHandleClass() {\r\n      if (this.renderRtl) {\r\n        return \"vue-resizable-handle vue-rtl-resizable-handle\";\r\n      } else {\r\n        return \"vue-resizable-handle\";\r\n      }\r\n    },\r\n  },\r\n  methods: {\r\n    createStyle: function() {\r\n      if (this.x + this.w > this.cols) {\r\n        this.innerX = 0;\r\n        this.innerW = this.w > this.cols ? this.cols : this.w;\r\n      } else {\r\n        this.innerX = this.x;\r\n        this.innerW = this.w;\r\n      }\r\n      let pos = this.calcPosition(\r\n        this.innerX,\r\n        this.innerY,\r\n        this.innerW,\r\n        this.innerH\r\n      );\r\n\r\n      if (this.isDragging) {\r\n        pos.top = this.dragging.top;\r\n        //                    Add rtl support\r\n        if (this.renderRtl) {\r\n          pos.right = this.dragging.left;\r\n        } else {\r\n          pos.left = this.dragging.left;\r\n        }\r\n      }\r\n      if (this.isResizing) {\r\n        pos.width = this.resizing.width;\r\n        pos.height = this.resizing.height;\r\n      }\r\n\r\n      let style;\r\n      // CSS Transforms support (default)\r\n      if (this.useCssTransforms) {\r\n        //                    Add rtl support\r\n        if (this.renderRtl) {\r\n          style = setTransformRtl(pos.top, pos.right, pos.width, pos.height);\r\n        } else {\r\n          style = setTransform(pos.top, pos.left, pos.width, pos.height);\r\n        }\r\n      } else {\r\n        // top,left (slow)\r\n        //                    Add rtl support\r\n        if (this.renderRtl) {\r\n          style = setTopRight(pos.top, pos.right, pos.width, pos.height);\r\n        } else {\r\n          style = setTopLeft(pos.top, pos.left, pos.width, pos.height);\r\n        }\r\n      }\r\n      this.style = style;\r\n    },\r\n    emitContainerResized() {\r\n      // this.style has width and height with trailing 'px'. The\r\n      // resized event is without them\r\n      let styleProps = {};\r\n      for (let prop of [\"width\", \"height\"]) {\r\n        let val = this.style[prop];\r\n        let matches = val.match(/^(\\d+)px$/);\r\n        if (!matches) return;\r\n        styleProps[prop] = matches[1];\r\n      }\r\n      this.$emit(\r\n        \"container-resized\",\r\n        this.i,\r\n        this.h,\r\n        this.w,\r\n        styleProps.height,\r\n        styleProps.width\r\n      );\r\n    },\r\n    handleResize: function(event) {\r\n      if (this.static) return;\r\n      const position = getControlPosition(event);\r\n      // Get the current drag point from the event. This is used as the offset.\r\n      if (position == null) return; // not possible but satisfies flow\r\n      const { x, y } = position;\r\n\r\n      const newSize = { width: 0, height: 0 };\r\n      let pos;\r\n      switch (event.type) {\r\n        case \"resizestart\": {\r\n          this.previousW = this.innerW;\r\n          this.previousH = this.innerH;\r\n          pos = this.calcPosition(\r\n            this.innerX,\r\n            this.innerY,\r\n            this.innerW,\r\n            this.innerH\r\n          );\r\n          newSize.width = pos.width;\r\n          newSize.height = pos.height;\r\n          this.resizing = newSize;\r\n          this.isResizing = true;\r\n          break;\r\n        }\r\n        case \"resizemove\": {\r\n          //                        console.log(\"### resize => \" + event.type + \", lastW=\" + this.lastW + \", lastH=\" + this.lastH);\r\n          const coreEvent = createCoreData(this.lastW, this.lastH, x, y);\r\n          if (this.renderRtl) {\r\n            newSize.width = this.resizing.width - coreEvent.deltaX;\r\n          } else {\r\n            newSize.width = this.resizing.width + coreEvent.deltaX;\r\n          }\r\n          newSize.height = this.resizing.height + coreEvent.deltaY;\r\n\r\n          ///console.log(\"### resize => \" + event.type + \", deltaX=\" + coreEvent.deltaX + \", deltaY=\" + coreEvent.deltaY);\r\n          this.resizing = newSize;\r\n          break;\r\n        }\r\n        case \"resizeend\": {\r\n          //console.log(\"### resize end => x=\" +this.innerX + \" y=\" + this.innerY + \" w=\" + this.innerW + \" h=\" + this.innerH);\r\n          pos = this.calcPosition(\r\n            this.innerX,\r\n            this.innerY,\r\n            this.innerW,\r\n            this.innerH\r\n          );\r\n          newSize.width = pos.width;\r\n          newSize.height = pos.height;\r\n          //                        console.log(\"### resize end => \" + JSON.stringify(newSize));\r\n          this.resizing = null;\r\n          this.isResizing = false;\r\n          break;\r\n        }\r\n      }\r\n      // Get new WH\r\n      pos = this.calcWH(newSize.height, newSize.width);\r\n      if (pos.w < this.minW) {\r\n        pos.w = this.minW;\r\n      }\r\n      if (pos.w > this.maxW) {\r\n        pos.w = this.maxW;\r\n      }\r\n      if (pos.h < this.minH) {\r\n        pos.h = this.minH;\r\n      }\r\n      if (pos.h > this.maxH) {\r\n        pos.h = this.maxH;\r\n      }\r\n\r\n      if (pos.h < 1) {\r\n        pos.h = 1;\r\n      }\r\n      if (pos.w < 1) {\r\n        pos.w = 1;\r\n      }\r\n\r\n      this.lastW = x;\r\n      this.lastH = y;\r\n\r\n      if (this.innerW !== pos.w || this.innerH !== pos.h) {\r\n        this.$emit(\r\n          \"resize\",\r\n          this.i,\r\n          pos.h,\r\n          pos.w,\r\n          newSize.height,\r\n          newSize.width\r\n        );\r\n      }\r\n      if (\r\n        event.type === \"resizeend\" &&\r\n        (this.previousW !== this.innerW || this.previousH !== this.innerH)\r\n      ) {\r\n        this.$emit(\r\n          \"resized\",\r\n          this.i,\r\n          pos.h,\r\n          pos.w,\r\n          newSize.height,\r\n          newSize.width\r\n        );\r\n      }\r\n      this.eventBus.$emit(\r\n        \"resizeEvent\",\r\n        event.type,\r\n        this.i,\r\n        this.innerX,\r\n        this.innerY,\r\n        pos.h,\r\n        pos.w\r\n      );\r\n    },\r\n    handleDrag(event) {\r\n      if (this.static) return;\r\n      if (this.isResizing) return;\r\n\r\n      const position = getControlPosition(event);\r\n\r\n      // Get the current drag point from the event. This is used as the offset.\r\n      if (position === null) return; // not possible but satisfies flow\r\n      const { x, y } = position;\r\n\r\n      // let shouldUpdate = false;\r\n      let newPosition = { top: 0, left: 0 };\r\n      switch (event.type) {\r\n        case \"dragstart\": {\r\n          this.previousX = this.innerX;\r\n          this.previousY = this.innerY;\r\n\r\n          let parentRect = event.target.offsetParent.getBoundingClientRect();\r\n          let clientRect = event.target.getBoundingClientRect();\r\n          if (this.renderRtl) {\r\n            newPosition.left = (clientRect.right - parentRect.right) * -1;\r\n          } else {\r\n            newPosition.left = clientRect.left - parentRect.left;\r\n          }\r\n          newPosition.top = clientRect.top - parentRect.top;\r\n          this.dragging = newPosition;\r\n          this.isDragging = true;\r\n          break;\r\n        }\r\n        case \"dragend\": {\r\n          if (!this.isDragging) return;\r\n          let parentRect = event.target.offsetParent.getBoundingClientRect();\r\n          let clientRect = event.target.getBoundingClientRect();\r\n          //                        Add rtl support\r\n          if (this.renderRtl) {\r\n            newPosition.left = (clientRect.right - parentRect.right) * -1;\r\n          } else {\r\n            newPosition.left = clientRect.left - parentRect.left;\r\n          }\r\n          newPosition.top = clientRect.top - parentRect.top;\r\n          //                        console.log(\"### drag end => \" + JSON.stringify(newPosition));\r\n          //                        console.log(\"### DROP: \" + JSON.stringify(newPosition));\r\n          this.dragging = null;\r\n          this.isDragging = false;\r\n          // shouldUpdate = true;\r\n          break;\r\n        }\r\n        case \"dragmove\": {\r\n          const coreEvent = createCoreData(this.lastX, this.lastY, x, y);\r\n          //                        Add rtl support\r\n          if (this.renderRtl) {\r\n            newPosition.left = this.dragging.left - coreEvent.deltaX;\r\n          } else {\r\n            newPosition.left = this.dragging.left + coreEvent.deltaX;\r\n          }\r\n          newPosition.top = this.dragging.top + coreEvent.deltaY;\r\n          //                        console.log(\"### drag => \" + event.type + \", x=\" + x + \", y=\" + y);\r\n          //                        console.log(\"### drag => \" + event.type + \", deltaX=\" + coreEvent.deltaX + \", deltaY=\" + coreEvent.deltaY);\r\n          //                        console.log(\"### drag end => \" + JSON.stringify(newPosition));\r\n          this.dragging = newPosition;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Get new XY\r\n      let pos;\r\n      if (this.renderRtl) {\r\n        pos = this.calcXY(newPosition.top, newPosition.left);\r\n      } else {\r\n        pos = this.calcXY(newPosition.top, newPosition.left);\r\n      }\r\n\r\n      this.lastX = x;\r\n      this.lastY = y;\r\n\r\n      if (this.innerX !== pos.x || this.innerY !== pos.y) {\r\n        this.$emit(\"move\", this.i, pos.x, pos.y);\r\n      }\r\n      if (\r\n        event.type === \"dragend\" &&\r\n        (this.previousX !== this.innerX || this.previousY !== this.innerY)\r\n      ) {\r\n        this.$emit(\"moved\", this.i, pos.x, pos.y);\r\n      }\r\n      this.eventBus.$emit(\r\n        \"dragEvent\",\r\n        event.type,\r\n        this.i,\r\n        pos.x,\r\n        pos.y,\r\n        this.innerH,\r\n        this.innerW\r\n      );\r\n    },\r\n    calcPosition: function(x, y, w, h) {\r\n      const colWidth = this.calcColWidth();\r\n      // add rtl support\r\n      let out;\r\n      if (this.renderRtl) {\r\n        out = {\r\n          right: Math.round(colWidth * x + (x + 1) * this.margin[0]),\r\n          top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),\r\n          // 0 * Infinity === NaN, which causes problems with resize constriants;\r\n          // Fix this if it occurs.\r\n          // Note we do it here rather than later because Math.round(Infinity) causes deopt\r\n          width:\r\n            w === Infinity\r\n              ? w\r\n              : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),\r\n          height:\r\n            h === Infinity\r\n              ? h\r\n              : Math.round(\r\n                  this.rowHeight * h + Math.max(0, h - 1) * this.margin[1]\r\n                ),\r\n        };\r\n      } else {\r\n        out = {\r\n          left: Math.round(colWidth * x + (x + 1) * this.margin[0]),\r\n          top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),\r\n          // 0 * Infinity === NaN, which causes problems with resize constriants;\r\n          // Fix this if it occurs.\r\n          // Note we do it here rather than later because Math.round(Infinity) causes deopt\r\n          width:\r\n            w === Infinity\r\n              ? w\r\n              : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),\r\n          height:\r\n            h === Infinity\r\n              ? h\r\n              : Math.round(\r\n                  this.rowHeight * h + Math.max(0, h - 1) * this.margin[1]\r\n                ),\r\n        };\r\n      }\r\n      return out;\r\n    },\r\n    /**\r\n     * Translate x and y coordinates from pixels to grid units.\r\n     * @param  {Number} top  Top position (relative to parent) in pixels.\r\n     * @param  {Number} left Left position (relative to parent) in pixels.\r\n     * @return {Object} x and y in grid units.\r\n     */\r\n    // TODO check if this function needs change in order to support rtl.\r\n    calcXY(top, left) {\r\n      const colWidth = this.calcColWidth();\r\n\r\n      // left = colWidth * x + margin * (x + 1)\r\n      // l = cx + m(x+1)\r\n      // l = cx + mx + m\r\n      // l - m = cx + mx\r\n      // l - m = x(c + m)\r\n      // (l - m) / (c + m) = x\r\n      // x = (left - margin) / (coldWidth + margin)\r\n      let x = Math.round((left - this.margin[0]) / (colWidth + this.margin[0]));\r\n      let y = Math.round(\r\n        (top - this.margin[1]) / (this.rowHeight + this.margin[1])\r\n      );\r\n      // Capping\r\n      x = Math.max(Math.min(x, this.cols - this.innerW), 0);\r\n      y = Math.max(Math.min(y, this.maxRows - this.innerH), 0);\r\n      if (y % 2 !== 0) {\r\n        y += 1;\r\n      }\r\n      return { x, y };\r\n    },\r\n    // Helper for generating column width\r\n    calcColWidth() {\r\n      const colWidth =\r\n        (this.containerWidth - this.margin[0] * (this.cols + 1)) / this.cols;\r\n      // console.log(\"### COLS=\" + this.cols + \" COL WIDTH=\" + colWidth + \" MARGIN \" + this.margin[0]);\r\n      return colWidth;\r\n    },\r\n\r\n    /**\r\n     * Given a height and width in pixel values, calculate grid units.\r\n     * @param  {Number} height Height in pixels.\r\n     * @param  {Number} width  Width in pixels.\r\n     * @return {Object} w, h as grid units.\r\n     */\r\n    calcWH(height, width) {\r\n      const colWidth = this.calcColWidth();\r\n\r\n      // width = colWidth * w - (margin * (w - 1))\r\n      // ...\r\n      // w = (width + margin) / (colWidth + margin)\r\n      let w = Math.round(\r\n        (width + this.margin[0]) / (colWidth + this.margin[0])\r\n      );\r\n      let h = Math.round(\r\n        (height + this.margin[1]) / (this.rowHeight + this.margin[1])\r\n      );\r\n      // Capping\r\n      w = Math.max(Math.min(w, this.cols - this.innerX), 0);\r\n      h = Math.max(Math.min(h, this.maxRows - this.innerY), 0);\r\n      if (h % 2 !== 0) {\r\n        h += 1;\r\n      }\r\n      return { w, h };\r\n    },\r\n    updateWidth: function(width, colNum) {\r\n      this.containerWidth = width;\r\n      if (colNum !== undefined && colNum !== null) {\r\n        this.cols = colNum;\r\n      }\r\n    },\r\n    compact: function() {\r\n      this.createStyle();\r\n    },\r\n    tryMakeDraggable: function() {\r\n      const self = this;\r\n      if (this.interactObj === null || this.interactObj === undefined) {\r\n        this.interactObj = interact(this.$refs.item);\r\n        if (!this.useStyleCursor) {\r\n          this.interactObj.styleCursor(false);\r\n        }\r\n      }\r\n      if (this.draggable && !this.static) {\r\n        const opts = {\r\n          ignoreFrom: this.dragIgnoreFrom,\r\n          allowFrom: this.dragAllowFrom,\r\n        };\r\n        this.interactObj.draggable(opts);\r\n        /*this.interactObj.draggable({allowFrom: '.vue-draggable-handle'});*/\r\n        if (!this.dragEventSet) {\r\n          this.dragEventSet = true;\r\n          this.interactObj.on(\"dragstart dragmove dragend\", function(event) {\r\n            self.handleDrag(event);\r\n          });\r\n        }\r\n      } else {\r\n        this.interactObj.draggable({\r\n          enabled: false,\r\n        });\r\n      }\r\n    },\r\n    tryMakeResizable: function() {\r\n      const self = this;\r\n      if (this.interactObj === null || this.interactObj === undefined) {\r\n        this.interactObj = interact(this.$refs.item);\r\n        if (!this.useStyleCursor) {\r\n          this.interactObj.styleCursor(false);\r\n        }\r\n      }\r\n      if (this.resizable && !this.static) {\r\n        let maximum = this.calcPosition(0, 0, this.maxW, this.maxH);\r\n        let minimum = this.calcPosition(0, 0, this.minW, this.minH);\r\n\r\n        // console.log(\"### MAX \" + JSON.stringify(maximum));\r\n        // console.log(\"### MIN \" + JSON.stringify(minimum));\r\n\r\n        const opts = {\r\n          // allowFrom: \".\" + this.resizableHandleClass.trim().replace(\" \", \".\"),\r\n          edges: {\r\n            left: false,\r\n            right: \".\" + this.resizableHandleClass.trim().replace(\" \", \".\"),\r\n            bottom: \".\" + this.resizableHandleClass.trim().replace(\" \", \".\"),\r\n            top: false,\r\n          },\r\n          ignoreFrom: this.resizeIgnoreFrom,\r\n          restrictSize: {\r\n            min: {\r\n              height: minimum.height,\r\n              width: minimum.width,\r\n            },\r\n            max: {\r\n              height: maximum.height,\r\n              width: maximum.width,\r\n            },\r\n          },\r\n        };\r\n\r\n        if (this.preserveAspectRatio) {\r\n          opts.modifiers = [\r\n            interact.modifiers.aspectRatio({\r\n              ratio: \"preserve\",\r\n            }),\r\n          ];\r\n        }\r\n\r\n        this.interactObj.resizable(opts);\r\n        if (!this.resizeEventSet) {\r\n          this.resizeEventSet = true;\r\n          this.interactObj.on(\"resizestart resizemove resizeend\", function(\r\n            event\r\n          ) {\r\n            self.handleResize(event);\r\n          });\r\n        }\r\n      } else {\r\n        this.interactObj.resizable({\r\n          enabled: false,\r\n        });\r\n      }\r\n    },\r\n    autoSize: function() {\r\n      // ok here we want to calculate if a resize is needed\r\n      this.previousW = this.innerW;\r\n      this.previousH = this.innerH;\r\n\r\n      let newSize = this.$slots.default[0].elm.getBoundingClientRect();\r\n      let pos = this.calcWH(newSize.height, newSize.width);\r\n      if (pos.w < this.minW) {\r\n        pos.w = this.minW;\r\n      }\r\n      if (pos.w > this.maxW) {\r\n        pos.w = this.maxW;\r\n      }\r\n      if (pos.h < this.minH) {\r\n        pos.h = this.minH;\r\n      }\r\n      if (pos.h > this.maxH) {\r\n        pos.h = this.maxH;\r\n      }\r\n\r\n      if (pos.h < 1) {\r\n        pos.h = 1;\r\n      }\r\n      if (pos.w < 1) {\r\n        pos.w = 1;\r\n      }\r\n\r\n      // this.lastW = x; // basically, this is copied from resizehandler, but shouldn't be needed\r\n      // this.lastH = y;\r\n\r\n      if (this.innerW !== pos.w || this.innerH !== pos.h) {\r\n        this.$emit(\r\n          \"resize\",\r\n          this.i,\r\n          pos.h,\r\n          pos.w,\r\n          newSize.height,\r\n          newSize.width\r\n        );\r\n      }\r\n      if (this.previousW !== pos.w || this.previousH !== pos.h) {\r\n        this.$emit(\r\n          \"resized\",\r\n          this.i,\r\n          pos.h,\r\n          pos.w,\r\n          newSize.height,\r\n          newSize.width\r\n        );\r\n        this.eventBus.$emit(\r\n          \"resizeEvent\",\r\n          \"resizeend\",\r\n          this.i,\r\n          this.innerX,\r\n          this.innerY,\r\n          pos.h,\r\n          pos.w\r\n        );\r\n      }\r\n    },\r\n  },\r\n};\r\n",{"version":3,"sources":["GridItem.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"GridItem.vue","sourceRoot":"src/components","sourcesContent":["<template>\r\n  <div ref=\"item\" class=\"vue-grid-item\" :class=\"classObj\" :style=\"style\">\r\n    <slot></slot>\r\n    <span\r\n      v-if=\"resizableAndNotStatic\"\r\n      ref=\"handle\"\r\n      :class=\"resizableHandleClass\"\r\n    ></span>\r\n    <!--<span v-if=\"draggable\" ref=\"dragHandle\" class=\"vue-draggable-handle\"></span>-->\r\n  </div>\r\n</template>\r\n<style>\r\n.vue-grid-item {\r\n  transition: all 200ms ease;\r\n  transition-property: left, top, right;\r\n  /* add right for rtl */\r\n}\r\n\r\n.vue-grid-item.no-touch {\r\n  -ms-touch-action: none;\r\n  touch-action: none;\r\n}\r\n\r\n.vue-grid-item.cssTransforms {\r\n  transition-property: transform;\r\n  left: 0;\r\n  right: auto;\r\n}\r\n\r\n.vue-grid-item.cssTransforms.render-rtl {\r\n  left: auto;\r\n  right: 0;\r\n}\r\n\r\n.vue-grid-item.resizing {\r\n  opacity: 0.6;\r\n  z-index: 3;\r\n}\r\n\r\n.vue-grid-item.vue-draggable-dragging {\r\n  transition: none;\r\n  z-index: 3;\r\n}\r\n\r\n.vue-grid-item.vue-grid-placeholder {\r\n  border: 0.5px solid #6d6e6e;\r\n  opacity: 0.2;\r\n  transition-duration: 100ms;\r\n  z-index: 2;\r\n  -webkit-user-select: none;\r\n  -moz-user-select: none;\r\n  -ms-user-select: none;\r\n  -o-user-select: none;\r\n  user-select: none;\r\n}\r\n\r\n.vue-grid-item > .vue-resizable-handle {\r\n  position: absolute;\r\n  width: 20px;\r\n  height: 20px;\r\n  bottom: 0;\r\n  right: 0;\r\n  background: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pg08IS0tIEdlbmVyYXRvcjogQWRvYmUgRmlyZXdvcmtzIENTNiwgRXhwb3J0IFNWRyBFeHRlbnNpb24gYnkgQWFyb24gQmVhbGwgKGh0dHA6Ly9maXJld29ya3MuYWJlYWxsLmNvbSkgLiBWZXJzaW9uOiAwLjYuMSAgLS0+DTwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DTxzdmcgaWQ9IlVudGl0bGVkLVBhZ2UlMjAxIiB2aWV3Qm94PSIwIDAgNiA2IiBzdHlsZT0iYmFja2dyb3VuZC1jb2xvcjojZmZmZmZmMDAiIHZlcnNpb249IjEuMSINCXhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbDpzcGFjZT0icHJlc2VydmUiDQl4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjZweCIgaGVpZ2h0PSI2cHgiDT4NCTxnIG9wYWNpdHk9IjAuMzAyIj4NCQk8cGF0aCBkPSJNIDYgNiBMIDAgNiBMIDAgNC4yIEwgNCA0LjIgTCA0LjIgNC4yIEwgNC4yIDAgTCA2IDAgTCA2IDYgTCA2IDYgWiIgZmlsbD0iIzAwMDAwMCIvPg0JPC9nPg08L3N2Zz4=\");\r\n  background-position: bottom right;\r\n  padding: 0 3px 3px 0;\r\n  background-repeat: no-repeat;\r\n  background-origin: content-box;\r\n  box-sizing: border-box;\r\n  cursor: se-resize;\r\n}\r\n\r\n.vue-grid-item > .vue-rtl-resizable-handle {\r\n  bottom: 0;\r\n  left: 0;\r\n  background: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAuMDAwMDAwMDAwMDAwMDAyIiBoZWlnaHQ9IjEwLjAwMDAwMDAwMDAwMDAwMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KIDwhLS0gQ3JlYXRlZCB3aXRoIE1ldGhvZCBEcmF3IC0gaHR0cDovL2dpdGh1Yi5jb20vZHVvcGl4ZWwvTWV0aG9kLURyYXcvIC0tPgogPGc+CiAgPHRpdGxlPmJhY2tncm91bmQ8L3RpdGxlPgogIDxyZWN0IGZpbGw9Im5vbmUiIGlkPSJjYW52YXNfYmFja2dyb3VuZCIgaGVpZ2h0PSIxMiIgd2lkdGg9IjEyIiB5PSItMSIgeD0iLTEiLz4KICA8ZyBkaXNwbGF5PSJub25lIiBvdmVyZmxvdz0idmlzaWJsZSIgeT0iMCIgeD0iMCIgaGVpZ2h0PSIxMDAlIiB3aWR0aD0iMTAwJSIgaWQ9ImNhbnZhc0dyaWQiPgogICA8cmVjdCBmaWxsPSJ1cmwoI2dyaWRwYXR0ZXJuKSIgc3Ryb2tlLXdpZHRoPSIwIiB5PSIwIiB4PSIwIiBoZWlnaHQ9IjEwMCUiIHdpZHRoPSIxMDAlIi8+CiAgPC9nPgogPC9nPgogPGc+CiAgPHRpdGxlPkxheWVyIDE8L3RpdGxlPgogIDxsaW5lIGNhbnZhcz0iI2ZmZmZmZiIgY2FudmFzLW9wYWNpdHk9IjEiIHN0cm9rZS1saW5lY2FwPSJ1bmRlZmluZWQiIHN0cm9rZS1saW5lam9pbj0idW5kZWZpbmVkIiBpZD0ic3ZnXzEiIHkyPSItNzAuMTc4NDA3IiB4Mj0iMTI0LjQ2NDE3NSIgeTE9Ii0zOC4zOTI3MzciIHgxPSIxNDQuODIxMjg5IiBzdHJva2Utd2lkdGg9IjEuNSIgc3Ryb2tlPSIjMDAwIiBmaWxsPSJub25lIi8+CiAgPGxpbmUgc3Ryb2tlPSIjNjY2NjY2IiBzdHJva2UtbGluZWNhcD0idW5kZWZpbmVkIiBzdHJva2UtbGluZWpvaW49InVuZGVmaW5lZCIgaWQ9InN2Z181IiB5Mj0iOS4xMDY5NTciIHgyPSIwLjk0NzI0NyIgeTE9Ii0wLjAxODEyOCIgeDE9IjAuOTQ3MjQ3IiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiLz4KICA8bGluZSBzdHJva2UtbGluZWNhcD0idW5kZWZpbmVkIiBzdHJva2UtbGluZWpvaW49InVuZGVmaW5lZCIgaWQ9InN2Z183IiB5Mj0iOSIgeDI9IjEwLjA3MzUyOSIgeTE9IjkiIHgxPSItMC42NTU2NCIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2U9IiM2NjY2NjYiIGZpbGw9Im5vbmUiLz4KIDwvZz4KPC9zdmc+);\r\n  background-position: bottom left;\r\n  padding-left: 3px;\r\n  background-repeat: no-repeat;\r\n  background-origin: content-box;\r\n  cursor: sw-resize;\r\n  right: auto;\r\n}\r\n\r\n.vue-grid-item.disable-userselect {\r\n  user-select: none;\r\n}\r\n</style>\r\n<script>\r\nimport {\r\n  setTopLeft,\r\n  setTopRight,\r\n  setTransformRtl,\r\n  setTransform,\r\n} from \"@/helpers/utils\";\r\nimport { getControlPosition, createCoreData } from \"@/helpers/draggableUtils\";\r\nimport { getColsFromBreakpoint } from \"@/helpers/responsiveUtils\";\r\nimport { getDocumentDir } from \"@/helpers/DOM\";\r\n//    var eventBus = require('./eventBus');\r\n\r\nimport \"@interactjs/auto-start\";\r\nimport \"@interactjs/actions/drag\";\r\nimport \"@interactjs/actions/resize\";\r\nimport \"@interactjs/modifiers\";\r\nimport \"@interactjs/dev-tools\";\r\nimport interact from \"@interactjs/interact\";\r\n\r\nexport default {\r\n  name: \"GridItem\",\r\n  props: {\r\n    /*cols: {\r\n             type: Number,\r\n             required: true\r\n             },*/\r\n    /*containerWidth: {\r\n             type: Number,\r\n             required: true\r\n\r\n             },\r\n             rowHeight: {\r\n             type: Number,\r\n             required: true\r\n             },\r\n             margin: {\r\n             type: Array,\r\n             required: true\r\n             },\r\n             maxRows: {\r\n             type: Number,\r\n             required: true\r\n             },*/\r\n    isDraggable: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: null,\r\n    },\r\n    isResizable: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: null,\r\n    },\r\n    /*useCssTransforms: {\r\n             type: Boolean,\r\n             required: true\r\n             },\r\n             */\r\n    static: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n    minH: {\r\n      type: Number,\r\n      required: false,\r\n      default: 1,\r\n    },\r\n    minW: {\r\n      type: Number,\r\n      required: false,\r\n      default: 1,\r\n    },\r\n    maxH: {\r\n      type: Number,\r\n      required: false,\r\n      default: Infinity,\r\n    },\r\n    maxW: {\r\n      type: Number,\r\n      required: false,\r\n      default: Infinity,\r\n    },\r\n    x: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    y: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    w: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    h: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    i: {\r\n      required: true,\r\n    },\r\n    dragIgnoreFrom: {\r\n      type: String,\r\n      required: false,\r\n      default: \"a, button\",\r\n    },\r\n    dragAllowFrom: {\r\n      type: String,\r\n      required: false,\r\n      default: null,\r\n    },\r\n    resizeIgnoreFrom: {\r\n      type: String,\r\n      required: false,\r\n      default: \"a, button\",\r\n    },\r\n    preserveAspectRatio: {\r\n      type: Boolean,\r\n      required: false,\r\n      default: false,\r\n    },\r\n  },\r\n  inject: [\"eventBus\", \"layout\"],\r\n  data: function() {\r\n    return {\r\n      cols: 1,\r\n      containerWidth: 100,\r\n      rowHeight: 30,\r\n      margin: [10, 10],\r\n      maxRows: Infinity,\r\n      draggable: null,\r\n      resizable: null,\r\n      useCssTransforms: true,\r\n      useStyleCursor: true,\r\n\r\n      isDragging: false,\r\n      dragging: null,\r\n      isResizing: false,\r\n      resizing: null,\r\n      lastX: NaN,\r\n      lastY: NaN,\r\n      lastW: NaN,\r\n      lastH: NaN,\r\n      style: {},\r\n      rtl: false,\r\n\r\n      dragEventSet: false,\r\n      resizeEventSet: false,\r\n\r\n      previousW: null,\r\n      previousH: null,\r\n      previousX: null,\r\n      previousY: null,\r\n      innerX: this.x,\r\n      innerY: this.y,\r\n      innerW: this.w,\r\n      innerH: this.h,\r\n    };\r\n  },\r\n  created() {\r\n    let self = this;\r\n\r\n    // Accessible refernces of functions for removing in beforeDestroy\r\n    self.updateWidthHandler = function(width) {\r\n      self.updateWidth(width);\r\n    };\r\n\r\n    self.compactHandler = function(layout) {\r\n      self.compact(layout);\r\n    };\r\n\r\n    self.setDraggableHandler = function(isDraggable) {\r\n      if (self.isDraggable === null) {\r\n        self.draggable = isDraggable;\r\n      }\r\n    };\r\n\r\n    self.setResizableHandler = function(isResizable) {\r\n      if (self.isResizable === null) {\r\n        self.resizable = isResizable;\r\n      }\r\n    };\r\n\r\n    self.setRowHeightHandler = function(rowHeight) {\r\n      self.rowHeight = rowHeight;\r\n    };\r\n\r\n    self.setMaxRowsHandler = function(maxRows) {\r\n      self.maxRows = maxRows;\r\n    };\r\n\r\n    self.directionchangeHandler = () => {\r\n      this.rtl = getDocumentDir() === \"rtl\";\r\n      this.compact();\r\n    };\r\n\r\n    self.setColNum = (colNum) => {\r\n      self.cols = parseInt(colNum);\r\n    };\r\n\r\n    this.eventBus.$on(\"updateWidth\", self.updateWidthHandler);\r\n    this.eventBus.$on(\"compact\", self.compactHandler);\r\n    this.eventBus.$on(\"setDraggable\", self.setDraggableHandler);\r\n    this.eventBus.$on(\"setResizable\", self.setResizableHandler);\r\n    this.eventBus.$on(\"setRowHeight\", self.setRowHeightHandler);\r\n    this.eventBus.$on(\"setMaxRows\", self.setMaxRowsHandler);\r\n    this.eventBus.$on(\"directionchange\", self.directionchangeHandler);\r\n    this.eventBus.$on(\"setColNum\", self.setColNum);\r\n\r\n    this.rtl = getDocumentDir() === \"rtl\";\r\n  },\r\n  beforeDestroy: function() {\r\n    let self = this;\r\n    //Remove listeners\r\n    this.eventBus.$off(\"updateWidth\", self.updateWidthHandler);\r\n    this.eventBus.$off(\"compact\", self.compactHandler);\r\n    this.eventBus.$off(\"setDraggable\", self.setDraggableHandler);\r\n    this.eventBus.$off(\"setResizable\", self.setResizableHandler);\r\n    this.eventBus.$off(\"setRowHeight\", self.setRowHeightHandler);\r\n    this.eventBus.$off(\"setMaxRows\", self.setMaxRowsHandler);\r\n    this.eventBus.$off(\"directionchange\", self.directionchangeHandler);\r\n    this.eventBus.$off(\"setColNum\", self.setColNum);\r\n    if (this.interactObj) {\r\n      this.interactObj.unset(); // destroy interact intance\r\n    }\r\n  },\r\n  mounted: function() {\r\n    if (this.layout.responsive && this.layout.lastBreakpoint) {\r\n      this.cols = getColsFromBreakpoint(\r\n        this.layout.lastBreakpoint,\r\n        this.layout.cols\r\n      );\r\n    } else {\r\n      this.cols = this.layout.colNum;\r\n    }\r\n    this.rowHeight = this.layout.rowHeight;\r\n    this.containerWidth = this.layout.width !== null ? this.layout.width : 100;\r\n    this.margin =\r\n      this.layout.margin !== undefined ? this.layout.margin : [10, 10];\r\n    this.maxRows = this.layout.maxRows;\r\n\r\n    if (this.isDraggable === null) {\r\n      this.draggable = this.layout.isDraggable;\r\n    } else {\r\n      this.draggable = this.isDraggable;\r\n    }\r\n    if (this.isResizable === null) {\r\n      this.resizable = this.layout.isResizable;\r\n    } else {\r\n      this.resizable = this.isResizable;\r\n    }\r\n    this.useCssTransforms = this.layout.useCssTransforms;\r\n    this.useStyleCursor = this.layout.useStyleCursor;\r\n    this.createStyle();\r\n  },\r\n  watch: {\r\n    isDraggable: function() {\r\n      this.draggable = this.isDraggable;\r\n    },\r\n    static: function() {\r\n      this.tryMakeDraggable();\r\n      this.tryMakeResizable();\r\n    },\r\n    draggable: function() {\r\n      this.tryMakeDraggable();\r\n    },\r\n    isResizable: function() {\r\n      this.resizable = this.isResizable;\r\n    },\r\n    resizable: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    rowHeight: function() {\r\n      this.createStyle();\r\n      this.emitContainerResized();\r\n    },\r\n    cols: function() {\r\n      this.tryMakeResizable();\r\n      this.createStyle();\r\n      this.emitContainerResized();\r\n    },\r\n    containerWidth: function() {\r\n      this.tryMakeResizable();\r\n      this.createStyle();\r\n      this.emitContainerResized();\r\n    },\r\n    x: function(newVal) {\r\n      this.innerX = newVal;\r\n      this.createStyle();\r\n    },\r\n    y: function(newVal) {\r\n      this.innerY = newVal;\r\n      this.createStyle();\r\n    },\r\n    h: function(newVal) {\r\n      this.innerH = newVal;\r\n      this.createStyle();\r\n      // this.emitContainerResized();\r\n    },\r\n    w: function(newVal) {\r\n      this.innerW = newVal;\r\n      this.createStyle();\r\n      // this.emitContainerResized();\r\n    },\r\n    renderRtl: function() {\r\n      // console.log(\"### renderRtl\");\r\n      this.tryMakeResizable();\r\n      this.createStyle();\r\n    },\r\n    minH: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    maxH: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    minW: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    maxW: function() {\r\n      this.tryMakeResizable();\r\n    },\r\n    \"$parent.margin\": function(margin) {\r\n      if (\r\n        !margin ||\r\n        (margin[0] == this.margin[0] && margin[1] == this.margin[1])\r\n      ) {\r\n        return;\r\n      }\r\n      this.margin = margin.map((m) => Number(m));\r\n      this.createStyle();\r\n      this.emitContainerResized();\r\n    },\r\n  },\r\n  computed: {\r\n    classObj() {\r\n      return {\r\n        \"vue-resizable\": this.resizableAndNotStatic,\r\n        static: this.static,\r\n        resizing: this.isResizing,\r\n        \"vue-draggable-dragging\": this.isDragging,\r\n        cssTransforms: this.useCssTransforms,\r\n        \"render-rtl\": this.renderRtl,\r\n        \"disable-userselect\": this.isDragging,\r\n        \"no-touch\": this.isAndroid && this.draggableOrResizableAndNotStatic,\r\n      };\r\n    },\r\n    resizableAndNotStatic() {\r\n      return this.resizable && !this.static;\r\n    },\r\n    draggableOrResizableAndNotStatic() {\r\n      return (this.draggable || this.resizable) && !this.static;\r\n    },\r\n    isAndroid() {\r\n      return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\r\n    },\r\n    renderRtl() {\r\n      return this.layout.isMirrored ? !this.rtl : this.rtl;\r\n    },\r\n    resizableHandleClass() {\r\n      if (this.renderRtl) {\r\n        return \"vue-resizable-handle vue-rtl-resizable-handle\";\r\n      } else {\r\n        return \"vue-resizable-handle\";\r\n      }\r\n    },\r\n  },\r\n  methods: {\r\n    createStyle: function() {\r\n      if (this.x + this.w > this.cols) {\r\n        this.innerX = 0;\r\n        this.innerW = this.w > this.cols ? this.cols : this.w;\r\n      } else {\r\n        this.innerX = this.x;\r\n        this.innerW = this.w;\r\n      }\r\n      let pos = this.calcPosition(\r\n        this.innerX,\r\n        this.innerY,\r\n        this.innerW,\r\n        this.innerH\r\n      );\r\n\r\n      if (this.isDragging) {\r\n        pos.top = this.dragging.top;\r\n        //                    Add rtl support\r\n        if (this.renderRtl) {\r\n          pos.right = this.dragging.left;\r\n        } else {\r\n          pos.left = this.dragging.left;\r\n        }\r\n      }\r\n      if (this.isResizing) {\r\n        pos.width = this.resizing.width;\r\n        pos.height = this.resizing.height;\r\n      }\r\n\r\n      let style;\r\n      // CSS Transforms support (default)\r\n      if (this.useCssTransforms) {\r\n        //                    Add rtl support\r\n        if (this.renderRtl) {\r\n          style = setTransformRtl(pos.top, pos.right, pos.width, pos.height);\r\n        } else {\r\n          style = setTransform(pos.top, pos.left, pos.width, pos.height);\r\n        }\r\n      } else {\r\n        // top,left (slow)\r\n        //                    Add rtl support\r\n        if (this.renderRtl) {\r\n          style = setTopRight(pos.top, pos.right, pos.width, pos.height);\r\n        } else {\r\n          style = setTopLeft(pos.top, pos.left, pos.width, pos.height);\r\n        }\r\n      }\r\n      this.style = style;\r\n    },\r\n    emitContainerResized() {\r\n      // this.style has width and height with trailing 'px'. The\r\n      // resized event is without them\r\n      let styleProps = {};\r\n      for (let prop of [\"width\", \"height\"]) {\r\n        let val = this.style[prop];\r\n        let matches = val.match(/^(\\d+)px$/);\r\n        if (!matches) return;\r\n        styleProps[prop] = matches[1];\r\n      }\r\n      this.$emit(\r\n        \"container-resized\",\r\n        this.i,\r\n        this.h,\r\n        this.w,\r\n        styleProps.height,\r\n        styleProps.width\r\n      );\r\n    },\r\n    handleResize: function(event) {\r\n      if (this.static) return;\r\n      const position = getControlPosition(event);\r\n      // Get the current drag point from the event. This is used as the offset.\r\n      if (position == null) return; // not possible but satisfies flow\r\n      const { x, y } = position;\r\n\r\n      const newSize = { width: 0, height: 0 };\r\n      let pos;\r\n      switch (event.type) {\r\n        case \"resizestart\": {\r\n          this.previousW = this.innerW;\r\n          this.previousH = this.innerH;\r\n          pos = this.calcPosition(\r\n            this.innerX,\r\n            this.innerY,\r\n            this.innerW,\r\n            this.innerH\r\n          );\r\n          newSize.width = pos.width;\r\n          newSize.height = pos.height;\r\n          this.resizing = newSize;\r\n          this.isResizing = true;\r\n          break;\r\n        }\r\n        case \"resizemove\": {\r\n          //                        console.log(\"### resize => \" + event.type + \", lastW=\" + this.lastW + \", lastH=\" + this.lastH);\r\n          const coreEvent = createCoreData(this.lastW, this.lastH, x, y);\r\n          if (this.renderRtl) {\r\n            newSize.width = this.resizing.width - coreEvent.deltaX;\r\n          } else {\r\n            newSize.width = this.resizing.width + coreEvent.deltaX;\r\n          }\r\n          newSize.height = this.resizing.height + coreEvent.deltaY;\r\n\r\n          ///console.log(\"### resize => \" + event.type + \", deltaX=\" + coreEvent.deltaX + \", deltaY=\" + coreEvent.deltaY);\r\n          this.resizing = newSize;\r\n          break;\r\n        }\r\n        case \"resizeend\": {\r\n          //console.log(\"### resize end => x=\" +this.innerX + \" y=\" + this.innerY + \" w=\" + this.innerW + \" h=\" + this.innerH);\r\n          pos = this.calcPosition(\r\n            this.innerX,\r\n            this.innerY,\r\n            this.innerW,\r\n            this.innerH\r\n          );\r\n          newSize.width = pos.width;\r\n          newSize.height = pos.height;\r\n          //                        console.log(\"### resize end => \" + JSON.stringify(newSize));\r\n          this.resizing = null;\r\n          this.isResizing = false;\r\n          break;\r\n        }\r\n      }\r\n      // Get new WH\r\n      pos = this.calcWH(newSize.height, newSize.width);\r\n      if (pos.w < this.minW) {\r\n        pos.w = this.minW;\r\n      }\r\n      if (pos.w > this.maxW) {\r\n        pos.w = this.maxW;\r\n      }\r\n      if (pos.h < this.minH) {\r\n        pos.h = this.minH;\r\n      }\r\n      if (pos.h > this.maxH) {\r\n        pos.h = this.maxH;\r\n      }\r\n\r\n      if (pos.h < 1) {\r\n        pos.h = 1;\r\n      }\r\n      if (pos.w < 1) {\r\n        pos.w = 1;\r\n      }\r\n\r\n      this.lastW = x;\r\n      this.lastH = y;\r\n\r\n      if (this.innerW !== pos.w || this.innerH !== pos.h) {\r\n        this.$emit(\r\n          \"resize\",\r\n          this.i,\r\n          pos.h,\r\n          pos.w,\r\n          newSize.height,\r\n          newSize.width\r\n        );\r\n      }\r\n      if (\r\n        event.type === \"resizeend\" &&\r\n        (this.previousW !== this.innerW || this.previousH !== this.innerH)\r\n      ) {\r\n        this.$emit(\r\n          \"resized\",\r\n          this.i,\r\n          pos.h,\r\n          pos.w,\r\n          newSize.height,\r\n          newSize.width\r\n        );\r\n      }\r\n      this.eventBus.$emit(\r\n        \"resizeEvent\",\r\n        event.type,\r\n        this.i,\r\n        this.innerX,\r\n        this.innerY,\r\n        pos.h,\r\n        pos.w\r\n      );\r\n    },\r\n    handleDrag(event) {\r\n      if (this.static) return;\r\n      if (this.isResizing) return;\r\n\r\n      const position = getControlPosition(event);\r\n\r\n      // Get the current drag point from the event. This is used as the offset.\r\n      if (position === null) return; // not possible but satisfies flow\r\n      const { x, y } = position;\r\n\r\n      // let shouldUpdate = false;\r\n      let newPosition = { top: 0, left: 0 };\r\n      switch (event.type) {\r\n        case \"dragstart\": {\r\n          this.previousX = this.innerX;\r\n          this.previousY = this.innerY;\r\n\r\n          let parentRect = event.target.offsetParent.getBoundingClientRect();\r\n          let clientRect = event.target.getBoundingClientRect();\r\n          if (this.renderRtl) {\r\n            newPosition.left = (clientRect.right - parentRect.right) * -1;\r\n          } else {\r\n            newPosition.left = clientRect.left - parentRect.left;\r\n          }\r\n          newPosition.top = clientRect.top - parentRect.top;\r\n          this.dragging = newPosition;\r\n          this.isDragging = true;\r\n          break;\r\n        }\r\n        case \"dragend\": {\r\n          if (!this.isDragging) return;\r\n          let parentRect = event.target.offsetParent.getBoundingClientRect();\r\n          let clientRect = event.target.getBoundingClientRect();\r\n          //                        Add rtl support\r\n          if (this.renderRtl) {\r\n            newPosition.left = (clientRect.right - parentRect.right) * -1;\r\n          } else {\r\n            newPosition.left = clientRect.left - parentRect.left;\r\n          }\r\n          newPosition.top = clientRect.top - parentRect.top;\r\n          //                        console.log(\"### drag end => \" + JSON.stringify(newPosition));\r\n          //                        console.log(\"### DROP: \" + JSON.stringify(newPosition));\r\n          this.dragging = null;\r\n          this.isDragging = false;\r\n          // shouldUpdate = true;\r\n          break;\r\n        }\r\n        case \"dragmove\": {\r\n          const coreEvent = createCoreData(this.lastX, this.lastY, x, y);\r\n          //                        Add rtl support\r\n          if (this.renderRtl) {\r\n            newPosition.left = this.dragging.left - coreEvent.deltaX;\r\n          } else {\r\n            newPosition.left = this.dragging.left + coreEvent.deltaX;\r\n          }\r\n          newPosition.top = this.dragging.top + coreEvent.deltaY;\r\n          //                        console.log(\"### drag => \" + event.type + \", x=\" + x + \", y=\" + y);\r\n          //                        console.log(\"### drag => \" + event.type + \", deltaX=\" + coreEvent.deltaX + \", deltaY=\" + coreEvent.deltaY);\r\n          //                        console.log(\"### drag end => \" + JSON.stringify(newPosition));\r\n          this.dragging = newPosition;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Get new XY\r\n      let pos;\r\n      if (this.renderRtl) {\r\n        pos = this.calcXY(newPosition.top, newPosition.left);\r\n      } else {\r\n        pos = this.calcXY(newPosition.top, newPosition.left);\r\n      }\r\n\r\n      this.lastX = x;\r\n      this.lastY = y;\r\n\r\n      if (this.innerX !== pos.x || this.innerY !== pos.y) {\r\n        this.$emit(\"move\", this.i, pos.x, pos.y);\r\n      }\r\n      if (\r\n        event.type === \"dragend\" &&\r\n        (this.previousX !== this.innerX || this.previousY !== this.innerY)\r\n      ) {\r\n        this.$emit(\"moved\", this.i, pos.x, pos.y);\r\n      }\r\n      this.eventBus.$emit(\r\n        \"dragEvent\",\r\n        event.type,\r\n        this.i,\r\n        pos.x,\r\n        pos.y,\r\n        this.innerH,\r\n        this.innerW\r\n      );\r\n    },\r\n    calcPosition: function(x, y, w, h) {\r\n      const colWidth = this.calcColWidth();\r\n      // add rtl support\r\n      let out;\r\n      if (this.renderRtl) {\r\n        out = {\r\n          right: Math.round(colWidth * x + (x + 1) * this.margin[0]),\r\n          top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),\r\n          // 0 * Infinity === NaN, which causes problems with resize constriants;\r\n          // Fix this if it occurs.\r\n          // Note we do it here rather than later because Math.round(Infinity) causes deopt\r\n          width:\r\n            w === Infinity\r\n              ? w\r\n              : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),\r\n          height:\r\n            h === Infinity\r\n              ? h\r\n              : Math.round(\r\n                  this.rowHeight * h + Math.max(0, h - 1) * this.margin[1]\r\n                ),\r\n        };\r\n      } else {\r\n        out = {\r\n          left: Math.round(colWidth * x + (x + 1) * this.margin[0]),\r\n          top: Math.round(this.rowHeight * y + (y + 1) * this.margin[1]),\r\n          // 0 * Infinity === NaN, which causes problems with resize constriants;\r\n          // Fix this if it occurs.\r\n          // Note we do it here rather than later because Math.round(Infinity) causes deopt\r\n          width:\r\n            w === Infinity\r\n              ? w\r\n              : Math.round(colWidth * w + Math.max(0, w - 1) * this.margin[0]),\r\n          height:\r\n            h === Infinity\r\n              ? h\r\n              : Math.round(\r\n                  this.rowHeight * h + Math.max(0, h - 1) * this.margin[1]\r\n                ),\r\n        };\r\n      }\r\n      return out;\r\n    },\r\n    /**\r\n     * Translate x and y coordinates from pixels to grid units.\r\n     * @param  {Number} top  Top position (relative to parent) in pixels.\r\n     * @param  {Number} left Left position (relative to parent) in pixels.\r\n     * @return {Object} x and y in grid units.\r\n     */\r\n    // TODO check if this function needs change in order to support rtl.\r\n    calcXY(top, left) {\r\n      const colWidth = this.calcColWidth();\r\n\r\n      // left = colWidth * x + margin * (x + 1)\r\n      // l = cx + m(x+1)\r\n      // l = cx + mx + m\r\n      // l - m = cx + mx\r\n      // l - m = x(c + m)\r\n      // (l - m) / (c + m) = x\r\n      // x = (left - margin) / (coldWidth + margin)\r\n      let x = Math.round((left - this.margin[0]) / (colWidth + this.margin[0]));\r\n      let y = Math.round(\r\n        (top - this.margin[1]) / (this.rowHeight + this.margin[1])\r\n      );\r\n      // Capping\r\n      x = Math.max(Math.min(x, this.cols - this.innerW), 0);\r\n      y = Math.max(Math.min(y, this.maxRows - this.innerH), 0);\r\n      if (y % 2 !== 0) {\r\n        y += 1;\r\n      }\r\n      return { x, y };\r\n    },\r\n    // Helper for generating column width\r\n    calcColWidth() {\r\n      const colWidth =\r\n        (this.containerWidth - this.margin[0] * (this.cols + 1)) / this.cols;\r\n      // console.log(\"### COLS=\" + this.cols + \" COL WIDTH=\" + colWidth + \" MARGIN \" + this.margin[0]);\r\n      return colWidth;\r\n    },\r\n\r\n    /**\r\n     * Given a height and width in pixel values, calculate grid units.\r\n     * @param  {Number} height Height in pixels.\r\n     * @param  {Number} width  Width in pixels.\r\n     * @return {Object} w, h as grid units.\r\n     */\r\n    calcWH(height, width) {\r\n      const colWidth = this.calcColWidth();\r\n\r\n      // width = colWidth * w - (margin * (w - 1))\r\n      // ...\r\n      // w = (width + margin) / (colWidth + margin)\r\n      let w = Math.round(\r\n        (width + this.margin[0]) / (colWidth + this.margin[0])\r\n      );\r\n      let h = Math.round(\r\n        (height + this.margin[1]) / (this.rowHeight + this.margin[1])\r\n      );\r\n      // Capping\r\n      w = Math.max(Math.min(w, this.cols - this.innerX), 0);\r\n      h = Math.max(Math.min(h, this.maxRows - this.innerY), 0);\r\n      if (h % 2 !== 0) {\r\n        h += 1;\r\n      }\r\n      return { w, h };\r\n    },\r\n    updateWidth: function(width, colNum) {\r\n      this.containerWidth = width;\r\n      if (colNum !== undefined && colNum !== null) {\r\n        this.cols = colNum;\r\n      }\r\n    },\r\n    compact: function() {\r\n      this.createStyle();\r\n    },\r\n    tryMakeDraggable: function() {\r\n      const self = this;\r\n      if (this.interactObj === null || this.interactObj === undefined) {\r\n        this.interactObj = interact(this.$refs.item);\r\n        if (!this.useStyleCursor) {\r\n          this.interactObj.styleCursor(false);\r\n        }\r\n      }\r\n      if (this.draggable && !this.static) {\r\n        const opts = {\r\n          ignoreFrom: this.dragIgnoreFrom,\r\n          allowFrom: this.dragAllowFrom,\r\n        };\r\n        this.interactObj.draggable(opts);\r\n        /*this.interactObj.draggable({allowFrom: '.vue-draggable-handle'});*/\r\n        if (!this.dragEventSet) {\r\n          this.dragEventSet = true;\r\n          this.interactObj.on(\"dragstart dragmove dragend\", function(event) {\r\n            self.handleDrag(event);\r\n          });\r\n        }\r\n      } else {\r\n        this.interactObj.draggable({\r\n          enabled: false,\r\n        });\r\n      }\r\n    },\r\n    tryMakeResizable: function() {\r\n      const self = this;\r\n      if (this.interactObj === null || this.interactObj === undefined) {\r\n        this.interactObj = interact(this.$refs.item);\r\n        if (!this.useStyleCursor) {\r\n          this.interactObj.styleCursor(false);\r\n        }\r\n      }\r\n      if (this.resizable && !this.static) {\r\n        let maximum = this.calcPosition(0, 0, this.maxW, this.maxH);\r\n        let minimum = this.calcPosition(0, 0, this.minW, this.minH);\r\n\r\n        // console.log(\"### MAX \" + JSON.stringify(maximum));\r\n        // console.log(\"### MIN \" + JSON.stringify(minimum));\r\n\r\n        const opts = {\r\n          // allowFrom: \".\" + this.resizableHandleClass.trim().replace(\" \", \".\"),\r\n          edges: {\r\n            left: false,\r\n            right: \".\" + this.resizableHandleClass.trim().replace(\" \", \".\"),\r\n            bottom: \".\" + this.resizableHandleClass.trim().replace(\" \", \".\"),\r\n            top: false,\r\n          },\r\n          ignoreFrom: this.resizeIgnoreFrom,\r\n          restrictSize: {\r\n            min: {\r\n              height: minimum.height,\r\n              width: minimum.width,\r\n            },\r\n            max: {\r\n              height: maximum.height,\r\n              width: maximum.width,\r\n            },\r\n          },\r\n        };\r\n\r\n        if (this.preserveAspectRatio) {\r\n          opts.modifiers = [\r\n            interact.modifiers.aspectRatio({\r\n              ratio: \"preserve\",\r\n            }),\r\n          ];\r\n        }\r\n\r\n        this.interactObj.resizable(opts);\r\n        if (!this.resizeEventSet) {\r\n          this.resizeEventSet = true;\r\n          this.interactObj.on(\"resizestart resizemove resizeend\", function(\r\n            event\r\n          ) {\r\n            self.handleResize(event);\r\n          });\r\n        }\r\n      } else {\r\n        this.interactObj.resizable({\r\n          enabled: false,\r\n        });\r\n      }\r\n    },\r\n    autoSize: function() {\r\n      // ok here we want to calculate if a resize is needed\r\n      this.previousW = this.innerW;\r\n      this.previousH = this.innerH;\r\n\r\n      let newSize = this.$slots.default[0].elm.getBoundingClientRect();\r\n      let pos = this.calcWH(newSize.height, newSize.width);\r\n      if (pos.w < this.minW) {\r\n        pos.w = this.minW;\r\n      }\r\n      if (pos.w > this.maxW) {\r\n        pos.w = this.maxW;\r\n      }\r\n      if (pos.h < this.minH) {\r\n        pos.h = this.minH;\r\n      }\r\n      if (pos.h > this.maxH) {\r\n        pos.h = this.maxH;\r\n      }\r\n\r\n      if (pos.h < 1) {\r\n        pos.h = 1;\r\n      }\r\n      if (pos.w < 1) {\r\n        pos.w = 1;\r\n      }\r\n\r\n      // this.lastW = x; // basically, this is copied from resizehandler, but shouldn't be needed\r\n      // this.lastH = y;\r\n\r\n      if (this.innerW !== pos.w || this.innerH !== pos.h) {\r\n        this.$emit(\r\n          \"resize\",\r\n          this.i,\r\n          pos.h,\r\n          pos.w,\r\n          newSize.height,\r\n          newSize.width\r\n        );\r\n      }\r\n      if (this.previousW !== pos.w || this.previousH !== pos.h) {\r\n        this.$emit(\r\n          \"resized\",\r\n          this.i,\r\n          pos.h,\r\n          pos.w,\r\n          newSize.height,\r\n          newSize.width\r\n        );\r\n        this.eventBus.$emit(\r\n          \"resizeEvent\",\r\n          \"resizeend\",\r\n          this.i,\r\n          this.innerX,\r\n          this.innerY,\r\n          pos.h,\r\n          pos.w\r\n        );\r\n      }\r\n    },\r\n  },\r\n};\r\n</script>\r\n"]}]}