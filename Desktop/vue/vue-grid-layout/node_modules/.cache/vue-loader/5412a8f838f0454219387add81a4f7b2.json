{"remainingRequest":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\components\\GridLayout.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\components\\GridLayout.vue","mtime":1620224294442},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\r\nimport Vue from \"vue\";\r\nconst elementResizeDetectorMaker = require(\"element-resize-detector\");\r\n\r\nimport {\r\n  bottom,\r\n  compact,\r\n  getLayoutItem,\r\n  moveElement,\r\n  validateLayout,\r\n  cloneLayout,\r\n  getAllCollisions,\r\n} from \"@/helpers/utils\";\r\nimport {\r\n  getBreakpointFromWidth,\r\n  getColsFromBreakpoint,\r\n  findOrGenerateResponsiveLayout,\r\n} from \"@/helpers/responsiveUtils\";\r\n//var eventBus = require('./eventBus');\r\n\r\nimport GridItem from \"./GridItem.vue\";\r\nimport {\r\n  addWindowEventListener,\r\n  removeWindowEventListener,\r\n} from \"@/helpers/DOM\";\r\n\r\nexport default {\r\n  name: \"GridLayout\",\r\n  provide() {\r\n    return {\r\n      eventBus: null,\r\n      layout: this,\r\n    };\r\n  },\r\n  components: {\r\n    GridItem,\r\n  },\r\n  props: {\r\n    // If true, the container height swells and contracts to fit contents\r\n    autoSize: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    colNum: {\r\n      type: Number,\r\n      default: 12,\r\n    },\r\n    rowHeight: {\r\n      type: Number,\r\n      default: 150,\r\n    },\r\n    maxRows: {\r\n      type: Number,\r\n      default: Infinity,\r\n    },\r\n    margin: {\r\n      type: Array,\r\n      default: function() {\r\n        return [10, 10];\r\n      },\r\n    },\r\n    isDraggable: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    isResizable: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    isMirrored: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    useCssTransforms: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    verticalCompact: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    layout: {\r\n      type: Array,\r\n      required: true,\r\n    },\r\n    responsive: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    responsiveLayouts: {\r\n      type: Object,\r\n      default: function() {\r\n        return {};\r\n      },\r\n    },\r\n    breakpoints: {\r\n      type: Object,\r\n      default: function() {\r\n        return { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 };\r\n      },\r\n    },\r\n    cols: {\r\n      type: Object,\r\n      default: function() {\r\n        return { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 };\r\n      },\r\n    },\r\n    preventCollision: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    useStyleCursor: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    minH: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n  },\r\n  data: function() {\r\n    return {\r\n      width: null,\r\n      mergedStyle: {},\r\n      lastLayoutLength: 0,\r\n      isDragging: false,\r\n      newBreakpoint: \"\",\r\n      placeholder: [],\r\n      layouts: {}, // array to store all layouts from different breakpoints\r\n      lastBreakpoint: null, // store last active breakpoint\r\n      originalLayout: null, // store original Layout\r\n    };\r\n  },\r\n  created() {\r\n    const self = this;\r\n\r\n    // Accessible refernces of functions for removing in beforeDestroy\r\n    self.resizeEventHandler = function(eventType, i, x, y, h, w) {\r\n      self.resizeEvent(eventType, i, x, y, h, w);\r\n    };\r\n\r\n    self.dragEventHandler = function(eventType, i, x, y, h, w) {\r\n      self.dragEvent(eventType, i, x, y, h, w);\r\n    };\r\n\r\n    self._provided.eventBus = new Vue();\r\n    self.eventBus = self._provided.eventBus;\r\n    self.eventBus.$on(\"resizeEvent\", self.resizeEventHandler);\r\n    self.eventBus.$on(\"dragEvent\", self.dragEventHandler);\r\n    self.$emit(\"layout-created\", self.layout);\r\n  },\r\n  beforeDestroy: function() {\r\n    //Remove listeners\r\n    this.eventBus.$off(\"resizeEvent\", this.resizeEventHandler);\r\n    this.eventBus.$off(\"dragEvent\", this.dragEventHandler);\r\n    this.eventBus.$destroy();\r\n    removeWindowEventListener(\"resize\", this.onWindowResize);\r\n    if (this.erd) {\r\n      this.erd.uninstall(this.$refs.item);\r\n    }\r\n  },\r\n  beforeMount: function() {\r\n    this.$emit(\"layout-before-mount\", this.layout);\r\n  },\r\n  mounted: function() {\r\n    this.$emit(\"layout-mounted\", this.layout);\r\n    this.$nextTick(function() {\r\n      validateLayout(this.layout);\r\n\r\n      this.originalLayout = this.layout;\r\n      const self = this;\r\n      this.$nextTick(function() {\r\n        self.onWindowResize();\r\n\r\n        self.initResponsiveFeatures();\r\n\r\n        //self.width = self.$el.offsetWidth;\r\n        addWindowEventListener(\"resize\", self.onWindowResize);\r\n\r\n        compact(self.layout, self.verticalCompact);\r\n\r\n        self.$emit(\"layout-updated\", self.layout);\r\n\r\n        self.updateHeight();\r\n        self.$nextTick(function() {\r\n          this.erd = elementResizeDetectorMaker({\r\n            strategy: \"scroll\", //<- For ultra performance.\r\n            // See https://github.com/wnr/element-resize-detector/issues/110 about callOnAdd.\r\n            callOnAdd: false,\r\n          });\r\n          this.erd.listenTo(self.$refs.item, function() {\r\n            self.onWindowResize();\r\n          });\r\n        });\r\n      });\r\n    });\r\n  },\r\n  watch: {\r\n    width: function(newval, oldval) {\r\n      const self = this;\r\n      this.$nextTick(function() {\r\n        //this.$broadcast(\"updateWidth\", this.width);\r\n        this.eventBus.$emit(\"updateWidth\", this.width);\r\n        if (oldval === null) {\r\n          /*\r\n                            If oldval == null is when the width has never been\r\n                            set before. That only occurs when mouting is\r\n                            finished, and onWindowResize has been called and\r\n                            this.width has been changed the first time after it\r\n                            got set to null in the constructor. It is now time\r\n                            to issue layout-ready events as the GridItems have\r\n                            their sizes configured properly.\r\n\r\n                            The reason for emitting the layout-ready events on\r\n                            the next tick is to allow for the newly-emitted\r\n                            updateWidth event (above) to have reached the\r\n                            children GridItem-s and had their effect, so we're\r\n                            sure that they have the final size before we emit\r\n                            layout-ready (for this GridLayout) and\r\n                            item-layout-ready (for the GridItem-s).\r\n\r\n                            This way any client event handlers can reliably\r\n                            invistigate stable sizes of GridItem-s.\r\n                        */\r\n          this.$nextTick(() => {\r\n            this.$emit(\"layout-ready\", self.layout);\r\n          });\r\n        }\r\n        this.updateHeight();\r\n      });\r\n    },\r\n    layout: function() {\r\n      this.layoutUpdate();\r\n    },\r\n    colNum: function(val) {\r\n      this.eventBus.$emit(\"setColNum\", val);\r\n    },\r\n    rowHeight: function() {\r\n      this.eventBus.$emit(\"setRowHeight\", this.rowHeight);\r\n    },\r\n    isDraggable: function() {\r\n      this.eventBus.$emit(\"setDraggable\", this.isDraggable);\r\n    },\r\n    isResizable: function() {\r\n      this.eventBus.$emit(\"setResizable\", this.isResizable);\r\n    },\r\n    responsive() {\r\n      if (!this.responsive) {\r\n        this.$emit(\"update:layout\", this.originalLayout);\r\n        this.eventBus.$emit(\"setColNum\", this.colNum);\r\n      }\r\n      this.onWindowResize();\r\n    },\r\n    maxRows: function() {\r\n      this.eventBus.$emit(\"setMaxRows\", this.maxRows);\r\n    },\r\n    margin() {\r\n      this.updateHeight();\r\n    },\r\n  },\r\n  methods: {\r\n    layoutUpdate() {\r\n      if (this.layout !== undefined && this.originalLayout !== null) {\r\n        if (this.layout.length !== this.originalLayout.length) {\r\n          // console.log(\"### LAYOUT UPDATE!\", this.layout.length, this.originalLayout.length);\r\n\r\n          let diff = this.findDifference(this.layout, this.originalLayout);\r\n          if (diff.length > 0) {\r\n            // console.log(diff);\r\n            if (this.layout.length > this.originalLayout.length) {\r\n              this.originalLayout = this.originalLayout.concat(diff);\r\n            } else {\r\n              this.originalLayout = this.originalLayout.filter((obj) => {\r\n                return !diff.some((obj2) => {\r\n                  return obj.i === obj2.i;\r\n                });\r\n              });\r\n            }\r\n          }\r\n\r\n          this.lastLayoutLength = this.layout.length;\r\n          this.initResponsiveFeatures();\r\n        }\r\n\r\n        compact(this.layout, this.verticalCompact);\r\n        this.eventBus.$emit(\"updateWidth\", this.width);\r\n        this.updateHeight();\r\n\r\n        this.$emit(\"layout-updated\", this.layout);\r\n      }\r\n    },\r\n    updateHeight: function() {\r\n      this.mergedStyle = {\r\n        height: this.minH\r\n          ? this.calcPosition(this.minH) + \"px\"\r\n          : this.containerHeight(),\r\n      };\r\n    },\r\n    onWindowResize: function() {\r\n      if (\r\n        this.$refs !== null &&\r\n        this.$refs.item !== null &&\r\n        this.$refs.item !== undefined\r\n      ) {\r\n        this.width = this.$refs.item.offsetWidth;\r\n      }\r\n      this.eventBus.$emit(\"resizeEvent\");\r\n    },\r\n    containerHeight: function() {\r\n      if (!this.autoSize) return;\r\n      // console.log(\"bottom: \" + bottom(this.layout))\r\n      // console.log(\"rowHeight + margins: \" + (this.rowHeight + this.margin[1]) + this.margin[1])\r\n      const containerHeight =\r\n        bottom(this.layout) * (this.rowHeight + this.margin[1]) +\r\n        this.margin[1] +\r\n        \"px\";\r\n      // For calculate by number of rows rather than pixels\r\n      this.$emit(\r\n        \"layoutHeight\",\r\n        this.calcContainerHeightByRow(\r\n          bottom(this.layout) * (this.rowHeight + this.margin[1]) +\r\n            this.margin[0]\r\n        )\r\n      );\r\n      return containerHeight;\r\n    },\r\n    containerHeightPlacerholder: function() {\r\n      if (!this.autoSize) return;\r\n      // console.log(\"bottom: \" + bottom(this.layout))\r\n      // console.log(\"rowHeight + margins: \" + (this.rowHeight + this.margin[1]) + this.margin[1])\r\n      //   console.log(bottom(this.layout), this.rowHeight, this.margin[1])\r\n      //   const containerHeight =\r\n      //     bottom(this.layout) * (this.rowHeight + this.margin[1]) +\r\n      //     this.margin[1];\r\n      const calcMargin = Math.ceil(\r\n        (this.rowHeight + this.margin[1] + this.margin[0]) / 100\r\n      );\r\n      return this.minH ? this.minH - calcMargin : bottom(this.layout);\r\n    },\r\n    dragEvent: function(eventName, id, x, y, h, w) {\r\n      //console.log(eventName + \" id=\" + id + \", x=\" + x + \", y=\" + y);\r\n      const placeholderGrids = [];\r\n      let l = getLayoutItem(this.layout, id);\r\n      //GetLayoutItem sometimes returns null object\r\n      if (l === undefined || l === null) {\r\n        l = { x: 0, y: 0 };\r\n      }\r\n      if (eventName === \"dragmove\") {\r\n        this.placeholder = [];\r\n        for (let row = 0; row < this.containerHeightPlacerholder() - 1; row++) {\r\n          for (let col = 1; col <= this.cols[this.newBreakpoint]; col++) {\r\n            if (row % 2 === 0) {\r\n              placeholderGrids.push({\r\n                x: col,\r\n                y: row,\r\n                w: 1,\r\n                h: 2,\r\n                i: \"row\" + row,\r\n              });\r\n            } else {\r\n              row = row + 1;\r\n              placeholderGrids.push({\r\n                x: col,\r\n                y: row,\r\n                w: 1,\r\n                h: 2,\r\n                i: \"row\" + row,\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (eventName === \"dragmove\" || eventName === \"dragstart\") {\r\n        this.$nextTick(function() {\r\n          this.isDragging = true;\r\n          //   this.placeholder.length = this.containerHeightPlacerholder() -1;\r\n        });\r\n        //this.$broadcast(\"updateWidth\", this.width);\r\n        this.eventBus.$emit(\"updateWidth\", this.width);\r\n      } else {\r\n        this.$nextTick(function() {\r\n          this.isDragging = false;\r\n          this.placeholder = [];\r\n        });\r\n      }\r\n      if (this.placeholder.length !== placeholderGrids.length) {\r\n        this.placeholder = placeholderGrids;\r\n      }\r\n      // Move the element to the dragged location.\r\n      this.layout = moveElement(\r\n        this.layout,\r\n        l,\r\n        x,\r\n        y,\r\n        true,\r\n        this.preventCollision\r\n      );\r\n      compact(this.layout, this.verticalCompact);\r\n      // needed because vue can't detect changes on array element properties\r\n      this.eventBus.$emit(\"compact\");\r\n      this.updateHeight();\r\n      if (eventName === \"dragend\") this.$emit(\"layout-updated\", this.layout);\r\n    },\r\n    resizeEvent: function(eventName, id, x, y, h, w) {\r\n      let l = getLayoutItem(this.layout, id);\r\n      const placeholderGrids = [];\r\n      //GetLayoutItem sometimes return null object\r\n      if (l === undefined || l === null) {\r\n        l = { h: 0, w: 0 };\r\n      }\r\n\r\n      let hasCollisions;\r\n      if (this.preventCollision) {\r\n        const collisions = getAllCollisions(this.layout, { ...l, w, h }).filter(\r\n          (layoutItem) => layoutItem.i !== l.i\r\n        );\r\n        hasCollisions = collisions.length > 0;\r\n\r\n        // If we're colliding, we need adjust the placeholder.\r\n        if (hasCollisions) {\r\n          // adjust w && h to maximum allowed space\r\n          let leastX = Infinity,\r\n            leastY = Infinity;\r\n          collisions.forEach((layoutItem) => {\r\n            if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);\r\n            if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);\r\n          });\r\n          if (Number.isFinite(leastX)) l.w = leastX - l.x;\r\n          if (Number.isFinite(leastY)) l.h = leastY - l.y;\r\n        }\r\n      }\r\n\r\n      if (!hasCollisions) {\r\n        // Set new width and height.\r\n        l.w = w;\r\n        l.h = h;\r\n      }\r\n\r\n      if (eventName === \"resizestart\" || eventName === \"resizemove\") {\r\n        this.placeholder = [];\r\n        for (let row = 0; row < this.containerHeightPlacerholder() - 1; row++) {\r\n          for (let col = 1; col <= this.cols[this.newBreakpoint]; col++) {\r\n            if (row % 2 === 0) {\r\n              placeholderGrids.push({\r\n                x: col,\r\n                y: row,\r\n                w: 1,\r\n                h: 2,\r\n                i: \"row\" + row,\r\n              });\r\n            } else {\r\n              row = row + 1;\r\n              placeholderGrids.push({\r\n                x: col,\r\n                y: row,\r\n                w: 1,\r\n                h: 2,\r\n                i: \"row\" + row,\r\n              });\r\n            }\r\n          }\r\n        }\r\n        this.$nextTick(function() {\r\n          this.isDragging = true;\r\n        });\r\n        //this.$broadcast(\"updateWidth\", this.width);\r\n        this.eventBus.$emit(\"updateWidth\", this.width);\r\n      } else {\r\n        this.$nextTick(function() {\r\n          this.isDragging = false;\r\n        });\r\n      }\r\n      if (this.placeholder.length !== placeholderGrids.length) {\r\n        this.placeholder = placeholderGrids;\r\n      }\r\n      if (this.responsive) this.responsiveGridLayout();\r\n\r\n      compact(this.layout, this.verticalCompact);\r\n      this.eventBus.$emit(\"compact\");\r\n      this.updateHeight();\r\n\r\n      if (eventName === \"resizeend\") this.$emit(\"layout-updated\", this.layout);\r\n    },\r\n\r\n    // finds or generates new layouts for set breakpoints\r\n    responsiveGridLayout() {\r\n      let newBreakpoint = getBreakpointFromWidth(this.breakpoints, this.width);\r\n      let newCols = getColsFromBreakpoint(newBreakpoint, this.cols);\r\n      this.newBreakpoint = newBreakpoint;\r\n\r\n      // save actual layout in layouts\r\n      if (this.lastBreakpoint != null && !this.layouts[this.lastBreakpoint])\r\n        this.layouts[this.lastBreakpoint] = cloneLayout(this.layout);\r\n\r\n      // Find or generate a new layout.\r\n      let layout = findOrGenerateResponsiveLayout(\r\n        this.originalLayout,\r\n        this.layouts,\r\n        this.breakpoints,\r\n        newBreakpoint,\r\n        this.lastBreakpoint,\r\n        newCols,\r\n        this.verticalCompact\r\n      );\r\n      // Store the new layout.\r\n      this.layouts[newBreakpoint] = layout;\r\n\r\n      if (this.lastBreakpoint !== newBreakpoint) {\r\n        this.$emit(\"breakpoint-changed\", newBreakpoint, layout);\r\n      }\r\n      // new prop sync\r\n      this.$emit(\"update:layout\", layout);\r\n\r\n      this.lastBreakpoint = newBreakpoint;\r\n      this.eventBus.$emit(\r\n        \"setColNum\",\r\n        getColsFromBreakpoint(newBreakpoint, this.cols)\r\n      );\r\n    },\r\n\r\n    // clear all responsive layouts\r\n    initResponsiveFeatures() {\r\n      // clear layouts\r\n      this.layouts = Object.assign({}, this.responsiveLayouts);\r\n    },\r\n\r\n    // find difference in layouts\r\n    findDifference(layout, originalLayout) {\r\n      //Find values that are in result1 but not in result2\r\n      let uniqueResultOne = layout.filter(function(obj) {\r\n        return !originalLayout.some(function(obj2) {\r\n          return obj.i === obj2.i;\r\n        });\r\n      });\r\n\r\n      //Find values that are in result2 but not in result1\r\n      let uniqueResultTwo = originalLayout.filter(function(obj) {\r\n        return !layout.some(function(obj2) {\r\n          return obj.i === obj2.i;\r\n        });\r\n      });\r\n\r\n      //Combine the two arrays of unique entries#\r\n      return uniqueResultOne.concat(uniqueResultTwo);\r\n    },\r\n    calcPosition: function(h) {\r\n      let out = {\r\n        height:\r\n          h === Infinity\r\n            ? h\r\n            : Math.round(\r\n                this.rowHeight * h + Math.max(0, h - 1) * this.margin[1]\r\n              ) + this.minH,\r\n      };\r\n      return out.height;\r\n    },\r\n    calcContainerHeightByRow: function(h) {\r\n      let out = {\r\n        height:\r\n          h === Infinity\r\n            ? h\r\n            : Math.round((h - this.margin[1]) / this.rowHeight),\r\n      };\r\n\r\n      if (out.height % 2 !== 0) {\r\n        out.height += 1;\r\n      }\r\n      return out.height;\r\n    },\r\n  },\r\n};\r\n",{"version":3,"sources":["GridLayout.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"GridLayout.vue","sourceRoot":"src/components","sourcesContent":["<template>\r\n  <div ref=\"item\" class=\"vue-grid-layout\" :style=\"mergedStyle\">\r\n    <slot></slot>\r\n    <!-- <grid-item\r\n      class=\"vue-grid-placeholder\"\r\n      :x=\"test.x\"\r\n      :y=\"test.y\"\r\n      :w=\"test.w\"\r\n      :h=\"test.h\"\r\n      :i=\"test.i\"\r\n    ></grid-item> -->\r\n    <grid-item\r\n      class=\"vue-grid-placeholder\"\r\n      v-for=\"(item, index) in placeholder\"\r\n      :key=\"index + 'placeholder'\"\r\n      :x=\"item.x\"\r\n      :y=\"item.y\"\r\n      :w=\"item.w\"\r\n      :h=\"item.h\"\r\n      :i=\"item.i\"\r\n    ></grid-item>\r\n  </div>\r\n</template>\r\n<style>\r\n.vue-grid-layout {\r\n  position: relative;\r\n  transition: height 200ms ease;\r\n}\r\n</style>\r\n<script>\r\nimport Vue from \"vue\";\r\nconst elementResizeDetectorMaker = require(\"element-resize-detector\");\r\n\r\nimport {\r\n  bottom,\r\n  compact,\r\n  getLayoutItem,\r\n  moveElement,\r\n  validateLayout,\r\n  cloneLayout,\r\n  getAllCollisions,\r\n} from \"@/helpers/utils\";\r\nimport {\r\n  getBreakpointFromWidth,\r\n  getColsFromBreakpoint,\r\n  findOrGenerateResponsiveLayout,\r\n} from \"@/helpers/responsiveUtils\";\r\n//var eventBus = require('./eventBus');\r\n\r\nimport GridItem from \"./GridItem.vue\";\r\nimport {\r\n  addWindowEventListener,\r\n  removeWindowEventListener,\r\n} from \"@/helpers/DOM\";\r\n\r\nexport default {\r\n  name: \"GridLayout\",\r\n  provide() {\r\n    return {\r\n      eventBus: null,\r\n      layout: this,\r\n    };\r\n  },\r\n  components: {\r\n    GridItem,\r\n  },\r\n  props: {\r\n    // If true, the container height swells and contracts to fit contents\r\n    autoSize: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    colNum: {\r\n      type: Number,\r\n      default: 12,\r\n    },\r\n    rowHeight: {\r\n      type: Number,\r\n      default: 150,\r\n    },\r\n    maxRows: {\r\n      type: Number,\r\n      default: Infinity,\r\n    },\r\n    margin: {\r\n      type: Array,\r\n      default: function() {\r\n        return [10, 10];\r\n      },\r\n    },\r\n    isDraggable: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    isResizable: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    isMirrored: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    useCssTransforms: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    verticalCompact: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    layout: {\r\n      type: Array,\r\n      required: true,\r\n    },\r\n    responsive: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    responsiveLayouts: {\r\n      type: Object,\r\n      default: function() {\r\n        return {};\r\n      },\r\n    },\r\n    breakpoints: {\r\n      type: Object,\r\n      default: function() {\r\n        return { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 };\r\n      },\r\n    },\r\n    cols: {\r\n      type: Object,\r\n      default: function() {\r\n        return { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 };\r\n      },\r\n    },\r\n    preventCollision: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    useStyleCursor: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n    minH: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n  },\r\n  data: function() {\r\n    return {\r\n      width: null,\r\n      mergedStyle: {},\r\n      lastLayoutLength: 0,\r\n      isDragging: false,\r\n      newBreakpoint: \"\",\r\n      placeholder: [],\r\n      layouts: {}, // array to store all layouts from different breakpoints\r\n      lastBreakpoint: null, // store last active breakpoint\r\n      originalLayout: null, // store original Layout\r\n    };\r\n  },\r\n  created() {\r\n    const self = this;\r\n\r\n    // Accessible refernces of functions for removing in beforeDestroy\r\n    self.resizeEventHandler = function(eventType, i, x, y, h, w) {\r\n      self.resizeEvent(eventType, i, x, y, h, w);\r\n    };\r\n\r\n    self.dragEventHandler = function(eventType, i, x, y, h, w) {\r\n      self.dragEvent(eventType, i, x, y, h, w);\r\n    };\r\n\r\n    self._provided.eventBus = new Vue();\r\n    self.eventBus = self._provided.eventBus;\r\n    self.eventBus.$on(\"resizeEvent\", self.resizeEventHandler);\r\n    self.eventBus.$on(\"dragEvent\", self.dragEventHandler);\r\n    self.$emit(\"layout-created\", self.layout);\r\n  },\r\n  beforeDestroy: function() {\r\n    //Remove listeners\r\n    this.eventBus.$off(\"resizeEvent\", this.resizeEventHandler);\r\n    this.eventBus.$off(\"dragEvent\", this.dragEventHandler);\r\n    this.eventBus.$destroy();\r\n    removeWindowEventListener(\"resize\", this.onWindowResize);\r\n    if (this.erd) {\r\n      this.erd.uninstall(this.$refs.item);\r\n    }\r\n  },\r\n  beforeMount: function() {\r\n    this.$emit(\"layout-before-mount\", this.layout);\r\n  },\r\n  mounted: function() {\r\n    this.$emit(\"layout-mounted\", this.layout);\r\n    this.$nextTick(function() {\r\n      validateLayout(this.layout);\r\n\r\n      this.originalLayout = this.layout;\r\n      const self = this;\r\n      this.$nextTick(function() {\r\n        self.onWindowResize();\r\n\r\n        self.initResponsiveFeatures();\r\n\r\n        //self.width = self.$el.offsetWidth;\r\n        addWindowEventListener(\"resize\", self.onWindowResize);\r\n\r\n        compact(self.layout, self.verticalCompact);\r\n\r\n        self.$emit(\"layout-updated\", self.layout);\r\n\r\n        self.updateHeight();\r\n        self.$nextTick(function() {\r\n          this.erd = elementResizeDetectorMaker({\r\n            strategy: \"scroll\", //<- For ultra performance.\r\n            // See https://github.com/wnr/element-resize-detector/issues/110 about callOnAdd.\r\n            callOnAdd: false,\r\n          });\r\n          this.erd.listenTo(self.$refs.item, function() {\r\n            self.onWindowResize();\r\n          });\r\n        });\r\n      });\r\n    });\r\n  },\r\n  watch: {\r\n    width: function(newval, oldval) {\r\n      const self = this;\r\n      this.$nextTick(function() {\r\n        //this.$broadcast(\"updateWidth\", this.width);\r\n        this.eventBus.$emit(\"updateWidth\", this.width);\r\n        if (oldval === null) {\r\n          /*\r\n                            If oldval == null is when the width has never been\r\n                            set before. That only occurs when mouting is\r\n                            finished, and onWindowResize has been called and\r\n                            this.width has been changed the first time after it\r\n                            got set to null in the constructor. It is now time\r\n                            to issue layout-ready events as the GridItems have\r\n                            their sizes configured properly.\r\n\r\n                            The reason for emitting the layout-ready events on\r\n                            the next tick is to allow for the newly-emitted\r\n                            updateWidth event (above) to have reached the\r\n                            children GridItem-s and had their effect, so we're\r\n                            sure that they have the final size before we emit\r\n                            layout-ready (for this GridLayout) and\r\n                            item-layout-ready (for the GridItem-s).\r\n\r\n                            This way any client event handlers can reliably\r\n                            invistigate stable sizes of GridItem-s.\r\n                        */\r\n          this.$nextTick(() => {\r\n            this.$emit(\"layout-ready\", self.layout);\r\n          });\r\n        }\r\n        this.updateHeight();\r\n      });\r\n    },\r\n    layout: function() {\r\n      this.layoutUpdate();\r\n    },\r\n    colNum: function(val) {\r\n      this.eventBus.$emit(\"setColNum\", val);\r\n    },\r\n    rowHeight: function() {\r\n      this.eventBus.$emit(\"setRowHeight\", this.rowHeight);\r\n    },\r\n    isDraggable: function() {\r\n      this.eventBus.$emit(\"setDraggable\", this.isDraggable);\r\n    },\r\n    isResizable: function() {\r\n      this.eventBus.$emit(\"setResizable\", this.isResizable);\r\n    },\r\n    responsive() {\r\n      if (!this.responsive) {\r\n        this.$emit(\"update:layout\", this.originalLayout);\r\n        this.eventBus.$emit(\"setColNum\", this.colNum);\r\n      }\r\n      this.onWindowResize();\r\n    },\r\n    maxRows: function() {\r\n      this.eventBus.$emit(\"setMaxRows\", this.maxRows);\r\n    },\r\n    margin() {\r\n      this.updateHeight();\r\n    },\r\n  },\r\n  methods: {\r\n    layoutUpdate() {\r\n      if (this.layout !== undefined && this.originalLayout !== null) {\r\n        if (this.layout.length !== this.originalLayout.length) {\r\n          // console.log(\"### LAYOUT UPDATE!\", this.layout.length, this.originalLayout.length);\r\n\r\n          let diff = this.findDifference(this.layout, this.originalLayout);\r\n          if (diff.length > 0) {\r\n            // console.log(diff);\r\n            if (this.layout.length > this.originalLayout.length) {\r\n              this.originalLayout = this.originalLayout.concat(diff);\r\n            } else {\r\n              this.originalLayout = this.originalLayout.filter((obj) => {\r\n                return !diff.some((obj2) => {\r\n                  return obj.i === obj2.i;\r\n                });\r\n              });\r\n            }\r\n          }\r\n\r\n          this.lastLayoutLength = this.layout.length;\r\n          this.initResponsiveFeatures();\r\n        }\r\n\r\n        compact(this.layout, this.verticalCompact);\r\n        this.eventBus.$emit(\"updateWidth\", this.width);\r\n        this.updateHeight();\r\n\r\n        this.$emit(\"layout-updated\", this.layout);\r\n      }\r\n    },\r\n    updateHeight: function() {\r\n      this.mergedStyle = {\r\n        height: this.minH\r\n          ? this.calcPosition(this.minH) + \"px\"\r\n          : this.containerHeight(),\r\n      };\r\n    },\r\n    onWindowResize: function() {\r\n      if (\r\n        this.$refs !== null &&\r\n        this.$refs.item !== null &&\r\n        this.$refs.item !== undefined\r\n      ) {\r\n        this.width = this.$refs.item.offsetWidth;\r\n      }\r\n      this.eventBus.$emit(\"resizeEvent\");\r\n    },\r\n    containerHeight: function() {\r\n      if (!this.autoSize) return;\r\n      // console.log(\"bottom: \" + bottom(this.layout))\r\n      // console.log(\"rowHeight + margins: \" + (this.rowHeight + this.margin[1]) + this.margin[1])\r\n      const containerHeight =\r\n        bottom(this.layout) * (this.rowHeight + this.margin[1]) +\r\n        this.margin[1] +\r\n        \"px\";\r\n      // For calculate by number of rows rather than pixels\r\n      this.$emit(\r\n        \"layoutHeight\",\r\n        this.calcContainerHeightByRow(\r\n          bottom(this.layout) * (this.rowHeight + this.margin[1]) +\r\n            this.margin[0]\r\n        )\r\n      );\r\n      return containerHeight;\r\n    },\r\n    containerHeightPlacerholder: function() {\r\n      if (!this.autoSize) return;\r\n      // console.log(\"bottom: \" + bottom(this.layout))\r\n      // console.log(\"rowHeight + margins: \" + (this.rowHeight + this.margin[1]) + this.margin[1])\r\n      //   console.log(bottom(this.layout), this.rowHeight, this.margin[1])\r\n      //   const containerHeight =\r\n      //     bottom(this.layout) * (this.rowHeight + this.margin[1]) +\r\n      //     this.margin[1];\r\n      const calcMargin = Math.ceil(\r\n        (this.rowHeight + this.margin[1] + this.margin[0]) / 100\r\n      );\r\n      return this.minH ? this.minH - calcMargin : bottom(this.layout);\r\n    },\r\n    dragEvent: function(eventName, id, x, y, h, w) {\r\n      //console.log(eventName + \" id=\" + id + \", x=\" + x + \", y=\" + y);\r\n      const placeholderGrids = [];\r\n      let l = getLayoutItem(this.layout, id);\r\n      //GetLayoutItem sometimes returns null object\r\n      if (l === undefined || l === null) {\r\n        l = { x: 0, y: 0 };\r\n      }\r\n      if (eventName === \"dragmove\") {\r\n        this.placeholder = [];\r\n        for (let row = 0; row < this.containerHeightPlacerholder() - 1; row++) {\r\n          for (let col = 1; col <= this.cols[this.newBreakpoint]; col++) {\r\n            if (row % 2 === 0) {\r\n              placeholderGrids.push({\r\n                x: col,\r\n                y: row,\r\n                w: 1,\r\n                h: 2,\r\n                i: \"row\" + row,\r\n              });\r\n            } else {\r\n              row = row + 1;\r\n              placeholderGrids.push({\r\n                x: col,\r\n                y: row,\r\n                w: 1,\r\n                h: 2,\r\n                i: \"row\" + row,\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (eventName === \"dragmove\" || eventName === \"dragstart\") {\r\n        this.$nextTick(function() {\r\n          this.isDragging = true;\r\n          //   this.placeholder.length = this.containerHeightPlacerholder() -1;\r\n        });\r\n        //this.$broadcast(\"updateWidth\", this.width);\r\n        this.eventBus.$emit(\"updateWidth\", this.width);\r\n      } else {\r\n        this.$nextTick(function() {\r\n          this.isDragging = false;\r\n          this.placeholder = [];\r\n        });\r\n      }\r\n      if (this.placeholder.length !== placeholderGrids.length) {\r\n        this.placeholder = placeholderGrids;\r\n      }\r\n      // Move the element to the dragged location.\r\n      this.layout = moveElement(\r\n        this.layout,\r\n        l,\r\n        x,\r\n        y,\r\n        true,\r\n        this.preventCollision\r\n      );\r\n      compact(this.layout, this.verticalCompact);\r\n      // needed because vue can't detect changes on array element properties\r\n      this.eventBus.$emit(\"compact\");\r\n      this.updateHeight();\r\n      if (eventName === \"dragend\") this.$emit(\"layout-updated\", this.layout);\r\n    },\r\n    resizeEvent: function(eventName, id, x, y, h, w) {\r\n      let l = getLayoutItem(this.layout, id);\r\n      const placeholderGrids = [];\r\n      //GetLayoutItem sometimes return null object\r\n      if (l === undefined || l === null) {\r\n        l = { h: 0, w: 0 };\r\n      }\r\n\r\n      let hasCollisions;\r\n      if (this.preventCollision) {\r\n        const collisions = getAllCollisions(this.layout, { ...l, w, h }).filter(\r\n          (layoutItem) => layoutItem.i !== l.i\r\n        );\r\n        hasCollisions = collisions.length > 0;\r\n\r\n        // If we're colliding, we need adjust the placeholder.\r\n        if (hasCollisions) {\r\n          // adjust w && h to maximum allowed space\r\n          let leastX = Infinity,\r\n            leastY = Infinity;\r\n          collisions.forEach((layoutItem) => {\r\n            if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);\r\n            if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);\r\n          });\r\n          if (Number.isFinite(leastX)) l.w = leastX - l.x;\r\n          if (Number.isFinite(leastY)) l.h = leastY - l.y;\r\n        }\r\n      }\r\n\r\n      if (!hasCollisions) {\r\n        // Set new width and height.\r\n        l.w = w;\r\n        l.h = h;\r\n      }\r\n\r\n      if (eventName === \"resizestart\" || eventName === \"resizemove\") {\r\n        this.placeholder = [];\r\n        for (let row = 0; row < this.containerHeightPlacerholder() - 1; row++) {\r\n          for (let col = 1; col <= this.cols[this.newBreakpoint]; col++) {\r\n            if (row % 2 === 0) {\r\n              placeholderGrids.push({\r\n                x: col,\r\n                y: row,\r\n                w: 1,\r\n                h: 2,\r\n                i: \"row\" + row,\r\n              });\r\n            } else {\r\n              row = row + 1;\r\n              placeholderGrids.push({\r\n                x: col,\r\n                y: row,\r\n                w: 1,\r\n                h: 2,\r\n                i: \"row\" + row,\r\n              });\r\n            }\r\n          }\r\n        }\r\n        this.$nextTick(function() {\r\n          this.isDragging = true;\r\n        });\r\n        //this.$broadcast(\"updateWidth\", this.width);\r\n        this.eventBus.$emit(\"updateWidth\", this.width);\r\n      } else {\r\n        this.$nextTick(function() {\r\n          this.isDragging = false;\r\n        });\r\n      }\r\n      if (this.placeholder.length !== placeholderGrids.length) {\r\n        this.placeholder = placeholderGrids;\r\n      }\r\n      if (this.responsive) this.responsiveGridLayout();\r\n\r\n      compact(this.layout, this.verticalCompact);\r\n      this.eventBus.$emit(\"compact\");\r\n      this.updateHeight();\r\n\r\n      if (eventName === \"resizeend\") this.$emit(\"layout-updated\", this.layout);\r\n    },\r\n\r\n    // finds or generates new layouts for set breakpoints\r\n    responsiveGridLayout() {\r\n      let newBreakpoint = getBreakpointFromWidth(this.breakpoints, this.width);\r\n      let newCols = getColsFromBreakpoint(newBreakpoint, this.cols);\r\n      this.newBreakpoint = newBreakpoint;\r\n\r\n      // save actual layout in layouts\r\n      if (this.lastBreakpoint != null && !this.layouts[this.lastBreakpoint])\r\n        this.layouts[this.lastBreakpoint] = cloneLayout(this.layout);\r\n\r\n      // Find or generate a new layout.\r\n      let layout = findOrGenerateResponsiveLayout(\r\n        this.originalLayout,\r\n        this.layouts,\r\n        this.breakpoints,\r\n        newBreakpoint,\r\n        this.lastBreakpoint,\r\n        newCols,\r\n        this.verticalCompact\r\n      );\r\n      // Store the new layout.\r\n      this.layouts[newBreakpoint] = layout;\r\n\r\n      if (this.lastBreakpoint !== newBreakpoint) {\r\n        this.$emit(\"breakpoint-changed\", newBreakpoint, layout);\r\n      }\r\n      // new prop sync\r\n      this.$emit(\"update:layout\", layout);\r\n\r\n      this.lastBreakpoint = newBreakpoint;\r\n      this.eventBus.$emit(\r\n        \"setColNum\",\r\n        getColsFromBreakpoint(newBreakpoint, this.cols)\r\n      );\r\n    },\r\n\r\n    // clear all responsive layouts\r\n    initResponsiveFeatures() {\r\n      // clear layouts\r\n      this.layouts = Object.assign({}, this.responsiveLayouts);\r\n    },\r\n\r\n    // find difference in layouts\r\n    findDifference(layout, originalLayout) {\r\n      //Find values that are in result1 but not in result2\r\n      let uniqueResultOne = layout.filter(function(obj) {\r\n        return !originalLayout.some(function(obj2) {\r\n          return obj.i === obj2.i;\r\n        });\r\n      });\r\n\r\n      //Find values that are in result2 but not in result1\r\n      let uniqueResultTwo = originalLayout.filter(function(obj) {\r\n        return !layout.some(function(obj2) {\r\n          return obj.i === obj2.i;\r\n        });\r\n      });\r\n\r\n      //Combine the two arrays of unique entries#\r\n      return uniqueResultOne.concat(uniqueResultTwo);\r\n    },\r\n    calcPosition: function(h) {\r\n      let out = {\r\n        height:\r\n          h === Infinity\r\n            ? h\r\n            : Math.round(\r\n                this.rowHeight * h + Math.max(0, h - 1) * this.margin[1]\r\n              ) + this.minH,\r\n      };\r\n      return out.height;\r\n    },\r\n    calcContainerHeightByRow: function(h) {\r\n      let out = {\r\n        height:\r\n          h === Infinity\r\n            ? h\r\n            : Math.round((h - this.margin[1]) / this.rowHeight),\r\n      };\r\n\r\n      if (out.height % 2 !== 0) {\r\n        out.height += 1;\r\n      }\r\n      return out.height;\r\n    },\r\n  },\r\n};\r\n</script>\r\n"]}]}