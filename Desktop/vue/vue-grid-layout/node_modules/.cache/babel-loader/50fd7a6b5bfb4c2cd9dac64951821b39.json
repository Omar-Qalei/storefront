{"remainingRequest":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\eslint-loader\\index.js??ref--13-0!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\helpers\\utils.js","dependencies":[{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\helpers\\utils.js","mtime":1620691868293},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.sort\";\n// @flow\n\n/*:: export type LayoutItemRequired = { w: number, h: number, x: number, y: number, i: string };*/\n\n/*:: export type LayoutItem = LayoutItemRequired &\r\n{\r\n  minW?: number, minH?: number, maxW?: number, maxH?: number,\r\n  moved?: boolean, static?: boolean,\r\n  isDraggable?: ?boolean, isResizable?: ?boolean\r\n};*/\n\n/*:: export type Layout = Array<LayoutItem>;*/\n\nexport var statusCollides = true; // export type Position = {left: number, top: number, width: number, height: number};\n\n/*\r\nexport type DragCallbackData = {\r\n  node: HTMLElement,\r\n  x: number, y: number,\r\n  deltaX: number, deltaY: number,\r\n  lastX: number, lastY: number\r\n};\r\n*/\n// export type DragEvent = {e: Event} & DragCallbackData;\n\n// export type ResizeEvent = {e: Event, node: HTMLElement, size: Size};\n// const isProduction = process.env.NODE_ENV === 'production';\n\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\n\n/*:: export type Size = { width: number, height: number };*/\n\nexport function bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\nexport function cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Fast path to cloning, since this is monomorphic\n\nexport function cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  /*return {\r\n    w: layoutItem.w, h: layoutItem.h, x: layoutItem.x, y: layoutItem.y, i: layoutItem.i,\r\n    minW: layoutItem.minW, maxW: layoutItem.maxW, minH: layoutItem.minH, maxH: layoutItem.maxH,\r\n    moved: Boolean(layoutItem.moved), static: Boolean(layoutItem.static),\r\n    // These can be null\r\n    isDraggable: layoutItem.isDraggable, isResizable: layoutItem.isResizable\r\n  };*/\n  return JSON.parse(JSON.stringify(layoutItem));\n}\n/**\r\n * Given two layoutitems, check if they collide.\r\n *\r\n * @return {Boolean}   True if colliding.\r\n */\n\nexport function collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (statusCollides) {\n    if (l1 === l2) return false; // same element\n\n    if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n    if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n    if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n    if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n    // If want to margin between element set true\n\n    return true; // boxes overlap\n  } else {\n    return false;\n  }\n}\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\n// Overlap  ++ \n\nexport function compact(layout\n/*: Layout*/\n, verticalCompact\n/*: Boolean*/\n, allowCollides\n/*: Boolean*/\n)\n/*: Layout*/\n{\n  console.log('compactItem', allowCollides); // Statics go in the compareWith array right away so items flow around them.\n\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItemsByRowCol(layout); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = sorted[i]; // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, verticalCompact, allowCollides); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(l)] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n/**\r\n * Compact an item in the layout. Overlap\r\n */\n\nexport function compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, verticalCompact\n/*: boolean*/\n, allowCollides\n/*: Boolean*/\n)\n/*: LayoutItem*/\n{\n  statusCollides = allowCollides;\n\n  if (allowCollides) {\n    if (verticalCompact) {\n      // Move the element up as far as it can go without colliding.\n      while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n        l.y--;\n      }\n    } // Move it down, and keep moving it down if it's colliding.\n\n\n    var _collides;\n\n    while (_collides = getFirstCollision(compareWith, l)) {\n      l.y = _collides.y + _collides.h;\n    }\n  }\n\n  return l;\n}\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\n\nexport function correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\n\nexport function getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\n\nexport function getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nexport function getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\n\nexport function getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  //return [];\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout Full layout to modify.\r\n * @param  {LayoutItem} l      element to move.\r\n * @param  {Number}     [x]    X position in grid units.\r\n * @param  {Number}     [y]    Y position in grid units.\r\n * @param  {Boolean}    [isUserAction] If true, designates that the item we're moving is\r\n *                                     being dragged/resized by th euser.\r\n */\n\nexport function moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: Number*/\n, y\n/*: Number*/\n, isUserAction\n/*: Boolean*/\n, preventCollision\n/*: Boolean*/\n)\n/*: Layout*/\n{\n  if (l.static) return layout; // Short-circuit if nothing to do.\n  //if (l.y === y && l.x === x) return layout;\n\n  var oldX = l.x;\n  var oldY = l.y;\n  var movingUp = y && l.y > y; // This is quite a bit faster than extending the object\n\n  if (typeof x === 'number') l.x = x;\n  if (typeof y === 'number') l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItemsByRowCol(layout);\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n\n  if (preventCollision && collisions.length) {\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i]; // console.log('resolving collision between', l.i, 'at', l.y, 'and', collision.i, 'at', collision.y);\n    // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // This makes it feel a bit more precise by waiting to swap for just a bit when moving up.\n\n    if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);\n    }\n  }\n\n  return layout;\n}\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n * @param  {Boolean} [isUserAction]  If true, designates that the item we're moving is being dragged/resized\r\n *                                   by the user.\r\n */\n\nexport function moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  console.log('moveElementAwayFromCollision');\n  var preventCollision = false; // we're already colliding\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: itemToMove.x,\n      y: itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: '-1'\n    };\n    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      return moveElement(layout, itemToMove, undefined, fakeItem.y, preventCollision);\n    }\n  } // Previously this was optimized to move below the collision directly, but this can cause problems\n  // with cascading moves, as an item may actually leapflog a collision and cause a reversal in order.\n\n\n  return moveElement(layout, itemToMove, undefined, itemToMove.y + 1, preventCollision);\n}\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\n\nexport function perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + '%';\n}\nexport function setTransform(top, left, width, height)\n/*: Object*/\n{\n  // Replace unitless items with px\n  var translate = \"translate3d(\" + left + \"px,\" + top + \"px, 0)\";\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n/**\r\n * Just like the setTransform method, but instead it will return a negative value of right.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{transform: string, WebkitTransform: string, MozTransform: string, msTransform: string, OTransform: string, width: string, height: string, position: string}}\r\n */\n\nexport function setTransformRtl(top, right, width, height)\n/*: Object*/\n{\n  // Replace unitless items with px\n  var translate = \"translate3d(\" + right * -1 + \"px,\" + top + \"px, 0)\";\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\nexport function setTopLeft(top, left, width, height)\n/*: Object*/\n{\n  return {\n    top: top + \"px\",\n    left: left + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n/**\r\n * Just like the setTopLeft method, but instead, it will return a right property instead of left.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{top: string, right: string, width: string, height: string, position: string}}\r\n */\n\nexport function setTopRight(top, right, width, height)\n/*: Object*/\n{\n  return {\n    top: top + \"px\",\n    right: right + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\n\nexport function sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return [].concat(layout).sort(function (a, b) {\n    if (a.y === b.y && a.x === b.x) {\n      return 0;\n    }\n\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\r\n * Generate a layout using the initialLayout and children as a template.\r\n * Missing entries will be added, extraneous ones will be truncated.\r\n *\r\n * @param  {Array}  initialLayout Layout passed in through props.\r\n * @param  {String} breakpoint    Current responsive breakpoint.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout vertically.\r\n * @return {Array}                Working layout.\r\n */\n\n/*\r\nexport function synchronizeLayoutWithChildren(initialLayout: Layout, children: Array<React.Element>|React.Element,\r\n                                              cols: number, verticalCompact: boolean): Layout {\r\n  // ensure 'children' is always an array\r\n  if (!Array.isArray(children)) {\r\n    children = [children];\r\n  }\r\n  initialLayout = initialLayout || [];\r\n\r\n  // Generate one layout item per child.\r\n  let layout: Layout = [];\r\n  for (let i = 0, len = children.length; i < len; i++) {\r\n    let newItem;\r\n    const child = children[i];\r\n\r\n    // Don't overwrite if it already exists.\r\n    const exists = getLayoutItem(initialLayout, child.key || \"1\" /!* FIXME satisfies Flow *!/);\r\n    if (exists) {\r\n      newItem = exists;\r\n    } else {\r\n      const g = child.props._grid;\r\n\r\n      // Hey, this item has a _grid property, use it.\r\n      if (g) {\r\n        if (!isProduction) {\r\n          validateLayout([g], 'ReactGridLayout.children');\r\n        }\r\n        // Validated; add it to the layout. Bottom 'y' possible is the bottom of the layout.\r\n        // This allows you to do nice stuff like specify {y: Infinity}\r\n        if (verticalCompact) {\r\n          newItem = cloneLayoutItem({...g, y: Math.min(bottom(layout), g.y), i: child.key});\r\n        } else {\r\n          newItem = cloneLayoutItem({...g, y: g.y, i: child.key});\r\n        }\r\n      }\r\n      // Nothing provided: ensure this is added to the bottom\r\n      else {\r\n        newItem = cloneLayoutItem({w: 1, h: 1, x: 0, y: bottom(layout), i: child.key || \"1\"});\r\n      }\r\n    }\r\n    layout[i] = newItem;\r\n  }\r\n\r\n  // Correct the layout.\r\n  layout = correctBounds(layout, {cols: cols});\r\n  layout = compact(layout, verticalCompact);\r\n\r\n  return layout;\r\n}\r\n*/\n\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\n\nexport function validateLayout(layout\n/*: Layout*/\n, contextName\n/*: string*/\n)\n/*: void*/\n{\n  contextName = contextName || \"Layout\";\n  var subProps = ['x', 'y', 'w', 'h'];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== 'number') {\n        throw new Error('VueGridLayout: ' + contextName + '[' + i + '].' + subProps[j] + ' must be a number!');\n      }\n    }\n\n    if (item.i && typeof item.i !== 'string') {// number is also ok, so comment the error\n      // TODO confirm if commenting the line below doesn't cause unexpected problems\n      // throw new Error('VueGridLayout: ' + contextName + '[' + i + '].i must be a string!');\n    }\n\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\n      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].static must be a boolean!');\n    }\n  }\n} // Flow can't really figure this out, so we just use Object\n\nexport function autoBindHandlers(el\n/*: Object*/\n, fns\n/*: Array<string>*/\n)\n/*: void*/\n{\n  fns.forEach(function (key) {\n    return el[key] = el[key].bind(el);\n  });\n}\n/**\r\n * Convert a JS object to CSS string. Similar to React's output of CSS.\r\n * @param obj\r\n * @returns {string}\r\n */\n\nexport function createMarkup(obj) {\n  var keys = Object.keys(obj);\n  if (!keys.length) return '';\n  var i,\n      len = keys.length;\n  var result = '';\n\n  for (i = 0; i < len; i++) {\n    var key = keys[i];\n    var val = obj[key];\n    result += hyphenate(key) + ':' + addPx(key, val) + ';';\n  }\n\n  return result;\n}\n/* The following list is defined in React's core */\n\nexport var IS_UNITLESS = {\n  animationIterationCount: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridColumn: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // SVG-related properties\n  fillOpacity: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n/**\r\n * Will add px to the end of style values which are Numbers.\r\n * @param name\r\n * @param value\r\n * @returns {*}\r\n */\n\nexport function addPx(name, value) {\n  if (typeof value === 'number' && !IS_UNITLESS[name]) {\n    return value + 'px';\n  } else {\n    return value;\n  }\n}\n/**\r\n * Hyphenate a camelCase string.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n */\n\nexport var hyphenateRE = /([a-z\\d])([A-Z])/g;\nexport function hyphenate(str) {\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n}\nexport function findItemInArray(array, property, value) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i][property] == value) return true;\n  }\n\n  return false;\n}\nexport function findAndRemove(array, property, value) {\n  array.forEach(function (result, index) {\n    if (result[property] === value) {\n      //Remove from array\n      array.splice(index, 1);\n    }\n  });\n}",{"version":3,"sources":["C:/Users/omar-/Desktop/vue/vue-grid-layout/src/helpers/utils.js"],"names":["statusCollides","bottom","layout","max","bottomY","i","len","length","y","h","cloneLayout","newLayout","Array","cloneLayoutItem","layoutItem","JSON","parse","stringify","collides","l1","l2","x","w","compact","verticalCompact","allowCollides","console","log","compareWith","getStatics","sorted","sortLayoutItemsByRowCol","out","l","static","compactItem","push","indexOf","moved","getFirstCollision","correctBounds","bounds","collidesWith","cols","getLayoutItem","id","getAllCollisions","filter","moveElement","isUserAction","preventCollision","oldX","oldY","movingUp","reverse","collisions","collision","moveElementAwayFromCollision","itemToMove","fakeItem","Math","undefined","perc","num","setTransform","top","left","width","height","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","setTransformRtl","right","setTopLeft","setTopRight","concat","sort","a","b","validateLayout","contextName","subProps","isArray","Error","item","j","autoBindHandlers","el","fns","forEach","key","bind","createMarkup","obj","keys","Object","result","val","hyphenate","addPx","IS_UNITLESS","animationIterationCount","boxFlex","boxFlexGroup","boxOrdinalGroup","columnCount","flex","flexGrow","flexPositive","flexShrink","flexNegative","flexOrder","gridRow","gridColumn","fontWeight","lineClamp","lineHeight","opacity","order","orphans","tabSize","widows","zIndex","zoom","fillOpacity","stopOpacity","strokeDashoffset","strokeOpacity","strokeWidth","name","value","hyphenateRE","str","replace","toLowerCase","findItemInArray","array","property","findAndRemove","index","splice"],"mappings":"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","sourcesContent":["// @flow\r\nexport type LayoutItemRequired = { w: number, h: number, x: number, y: number, i: string };\r\nexport type LayoutItem = LayoutItemRequired &\r\n{\r\n  minW?: number, minH?: number, maxW?: number, maxH?: number,\r\n  moved?: boolean, static?: boolean,\r\n  isDraggable?: ?boolean, isResizable?: ?boolean\r\n};\r\nexport type Layout = Array<LayoutItem>;\r\n\r\nexport let statusCollides = true;\r\n// export type Position = {left: number, top: number, width: number, height: number};\r\n/*\r\nexport type DragCallbackData = {\r\n  node: HTMLElement,\r\n  x: number, y: number,\r\n  deltaX: number, deltaY: number,\r\n  lastX: number, lastY: number\r\n};\r\n*/\r\n// export type DragEvent = {e: Event} & DragCallbackData;\r\nexport type Size = { width: number, height: number };\r\n\r\n// export type ResizeEvent = {e: Event, node: HTMLElement, size: Size};\r\n\r\n// const isProduction = process.env.NODE_ENV === 'production';\r\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\r\nexport function bottom(layout: Layout): number {\r\n  let max = 0, bottomY;\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    bottomY = layout[i].y + layout[i].h;\r\n    if (bottomY > max) max = bottomY;\r\n  }\r\n  return max;\r\n}\r\n\r\nexport function cloneLayout(layout: Layout): Layout {\r\n  const newLayout = Array(layout.length);\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    newLayout[i] = cloneLayoutItem(layout[i]);\r\n  }\r\n  return newLayout;\r\n}\r\n\r\n// Fast path to cloning, since this is monomorphic\r\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\r\n  /*return {\r\n    w: layoutItem.w, h: layoutItem.h, x: layoutItem.x, y: layoutItem.y, i: layoutItem.i,\r\n    minW: layoutItem.minW, maxW: layoutItem.maxW, minH: layoutItem.minH, maxH: layoutItem.maxH,\r\n    moved: Boolean(layoutItem.moved), static: Boolean(layoutItem.static),\r\n    // These can be null\r\n    isDraggable: layoutItem.isDraggable, isResizable: layoutItem.isResizable\r\n  };*/\r\n  return JSON.parse(JSON.stringify(layoutItem));\r\n}\r\n\r\n/**\r\n * Given two layoutitems, check if they collide.\r\n *\r\n * @return {Boolean}   True if colliding.\r\n */\r\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\r\n  if (statusCollides) {\r\n    if (l1 === l2) return false; // same element\r\n    if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\r\n    if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\r\n    if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\r\n    if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\r\n\r\n    // If want to margin between element set true\r\n    return true; // boxes overlap\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\r\n\r\n\r\n// Overlap  ++ \r\nexport function compact(layout: Layout, verticalCompact: Boolean, allowCollides: Boolean): Layout {\r\n  console.log('compactItem', allowCollides)\r\n\r\n  // Statics go in the compareWith array right away so items flow around them.\r\n  const compareWith = getStatics(layout);\r\n  // We go through the items by row and column.\r\n  const sorted = sortLayoutItemsByRowCol(layout);\r\n  // Holding for new items.\r\n  const out = Array(layout.length);\r\n\r\n  for (let i = 0, len = sorted.length; i < len; i++) {\r\n    let l = sorted[i];\r\n\r\n    // Don't move static elements\r\n    if (!l.static) {\r\n      l = compactItem(compareWith, l, verticalCompact, allowCollides);\r\n\r\n      // Add to comparison array. We only collide with items before this one.\r\n      // Statics are already in this array.\r\n      compareWith.push(l);\r\n    }\r\n\r\n    // Add to output array to make sure they still come out in the right order.\r\n    out[layout.indexOf(l)] = l;\r\n\r\n    // Clear moved flag, if it exists.\r\n    l.moved = false;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Compact an item in the layout. Overlap\r\n */\r\nexport function compactItem(compareWith: Layout, l: LayoutItem, verticalCompact: boolean, allowCollides: Boolean): LayoutItem {\r\n  statusCollides = allowCollides;\r\n  if (allowCollides) {\r\n    if (verticalCompact) {\r\n      // Move the element up as far as it can go without colliding.\r\n      while (l.y > 0 && !getFirstCollision(compareWith, l)) {\r\n        l.y--;\r\n      }\r\n    }\r\n\r\n    // Move it down, and keep moving it down if it's colliding.\r\n    let collides;\r\n    while ((collides = getFirstCollision(compareWith, l))) {\r\n      l.y = collides.y + collides.h;\r\n    }\r\n  }\r\n  return l;\r\n}\r\n\r\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\r\nexport function correctBounds(layout: Layout, bounds: { cols: number }): Layout {\r\n  const collidesWith = getStatics(layout);\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    const l = layout[i];\r\n    // Overflows right\r\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\r\n    // Overflows left\r\n    if (l.x < 0) {\r\n      l.x = 0;\r\n      l.w = bounds.cols;\r\n    }\r\n    if (!l.static) collidesWith.push(l);\r\n    else {\r\n      // If this is static and collides with other statics, we must move it down.\r\n      // We have to do something nicer than just letting them overlap.\r\n      while (getFirstCollision(collidesWith, l)) {\r\n        l.y++;\r\n      }\r\n    }\r\n  }\r\n  return layout;\r\n}\r\n\r\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\r\nexport function getLayoutItem(layout: Layout, id: string): ?LayoutItem {\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    if (layout[i].i === id) return layout[i];\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\r\nexport function getFirstCollision(layout: Layout, layoutItem: LayoutItem): ?LayoutItem {\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    if (collides(layout[i], layoutItem)) return layout[i];\r\n  }\r\n}\r\n\r\nexport function getAllCollisions(layout: Layout, layoutItem: LayoutItem): Array<LayoutItem> {\r\n  return layout.filter((l) => collides(l, layoutItem));\r\n}\r\n\r\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\r\nexport function getStatics(layout: Layout): Array<LayoutItem> {\r\n  //return [];\r\n  return layout.filter((l) => l.static);\r\n}\r\n\r\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout Full layout to modify.\r\n * @param  {LayoutItem} l      element to move.\r\n * @param  {Number}     [x]    X position in grid units.\r\n * @param  {Number}     [y]    Y position in grid units.\r\n * @param  {Boolean}    [isUserAction] If true, designates that the item we're moving is\r\n *                                     being dragged/resized by th euser.\r\n */\r\nexport function moveElement(layout: Layout, l: LayoutItem, x: Number, y: Number, isUserAction: Boolean, preventCollision: Boolean): Layout {\r\n  if (l.static) return layout;\r\n  // Short-circuit if nothing to do.\r\n  //if (l.y === y && l.x === x) return layout;\r\n\r\n  const oldX = l.x;\r\n  const oldY = l.y;\r\n\r\n  const movingUp = y && l.y > y;\r\n  // This is quite a bit faster than extending the object\r\n  if (typeof x === 'number') l.x = x;\r\n  if (typeof y === 'number') l.y = y;\r\n  l.moved = true;\r\n\r\n  // If this collides with anything, move it.\r\n  // When doing this comparison, we have to sort the items we compare with\r\n  // to ensure, in the case of multiple collisions, that we're getting the\r\n  // nearest collision.\r\n  let sorted = sortLayoutItemsByRowCol(layout);\r\n  if (movingUp) sorted = sorted.reverse();\r\n\r\n  const collisions = getAllCollisions(sorted, l);\r\n\r\n  if (preventCollision && collisions.length) {\r\n    l.x = oldX;\r\n    l.y = oldY;\r\n    l.moved = false;\r\n    return layout;\r\n  }\r\n\r\n  // Move each item that collides away from this element.\r\n  for (let i = 0, len = collisions.length; i < len; i++) {\r\n    const collision = collisions[i];\r\n    // console.log('resolving collision between', l.i, 'at', l.y, 'and', collision.i, 'at', collision.y);\r\n\r\n    // Short circuit so we can't infinite loop\r\n    if (collision.moved) continue;\r\n\r\n    // This makes it feel a bit more precise by waiting to swap for just a bit when moving up.\r\n    if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue;\r\n\r\n    // Don't move static items - we have to move *this* element away\r\n    if (collision.static) {\r\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);\r\n    } else {\r\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);\r\n    }\r\n  }\r\n\r\n  return layout;\r\n}\r\n\r\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n * @param  {Boolean} [isUserAction]  If true, designates that the item we're moving is being dragged/resized\r\n *                                   by the user.\r\n */\r\nexport function moveElementAwayFromCollision(layout: Layout, collidesWith: LayoutItem,\r\n  itemToMove: LayoutItem, isUserAction: ?boolean): Layout {\r\n  console.log('moveElementAwayFromCollision');\r\n  const preventCollision = false // we're already colliding\r\n  // If there is enough space above the collision to put this element, move it there.\r\n  // We only do this on the main collision as this can get funky in cascades and cause\r\n  // unwanted swapping behavior.\r\n  if (isUserAction) {\r\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\r\n    const fakeItem: LayoutItem = {\r\n      x: itemToMove.x,\r\n      y: itemToMove.y,\r\n      w: itemToMove.w,\r\n      h: itemToMove.h,\r\n      i: '-1'\r\n    };\r\n    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);\r\n    if (!getFirstCollision(layout, fakeItem)) {\r\n      return moveElement(layout, itemToMove, undefined, fakeItem.y, preventCollision);\r\n    }\r\n  }\r\n\r\n  // Previously this was optimized to move below the collision directly, but this can cause problems\r\n  // with cascading moves, as an item may actually leapflog a collision and cause a reversal in order.\r\n  return moveElement(layout, itemToMove, undefined, itemToMove.y + 1, preventCollision);\r\n}\r\n\r\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\r\nexport function perc(num: number): string {\r\n  return num * 100 + '%';\r\n}\r\n\r\nexport function setTransform(top, left, width, height): Object {\r\n  // Replace unitless items with px\r\n  const translate = \"translate3d(\" + left + \"px,\" + top + \"px, 0)\";\r\n  return {\r\n    transform: translate,\r\n    WebkitTransform: translate,\r\n    MozTransform: translate,\r\n    msTransform: translate,\r\n    OTransform: translate,\r\n    width: width + \"px\",\r\n    height: height + \"px\",\r\n    position: 'absolute'\r\n  };\r\n}\r\n/**\r\n * Just like the setTransform method, but instead it will return a negative value of right.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{transform: string, WebkitTransform: string, MozTransform: string, msTransform: string, OTransform: string, width: string, height: string, position: string}}\r\n */\r\nexport function setTransformRtl(top, right, width, height): Object {\r\n  // Replace unitless items with px\r\n  const translate = \"translate3d(\" + right * -1 + \"px,\" + top + \"px, 0)\";\r\n  return {\r\n    transform: translate,\r\n    WebkitTransform: translate,\r\n    MozTransform: translate,\r\n    msTransform: translate,\r\n    OTransform: translate,\r\n    width: width + \"px\",\r\n    height: height + \"px\",\r\n    position: 'absolute'\r\n  };\r\n}\r\n\r\nexport function setTopLeft(top, left, width, height): Object {\r\n  return {\r\n    top: top + \"px\",\r\n    left: left + \"px\",\r\n    width: width + \"px\",\r\n    height: height + \"px\",\r\n    position: 'absolute'\r\n  };\r\n}\r\n/**\r\n * Just like the setTopLeft method, but instead, it will return a right property instead of left.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{top: string, right: string, width: string, height: string, position: string}}\r\n */\r\nexport function setTopRight(top, right, width, height): Object {\r\n  return {\r\n    top: top + \"px\",\r\n    right: right + \"px\",\r\n    width: width + \"px\",\r\n    height: height + \"px\",\r\n    position: 'absolute'\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\r\nexport function sortLayoutItemsByRowCol(layout: Layout): Layout {\r\n  return [].concat(layout).sort(function (a, b) {\r\n    if (a.y === b.y && a.x === b.x) {\r\n      return 0;\r\n    }\r\n\r\n    if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\r\n      return 1;\r\n    }\r\n\r\n    return -1;\r\n  });\r\n}\r\n\r\n/**\r\n * Generate a layout using the initialLayout and children as a template.\r\n * Missing entries will be added, extraneous ones will be truncated.\r\n *\r\n * @param  {Array}  initialLayout Layout passed in through props.\r\n * @param  {String} breakpoint    Current responsive breakpoint.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout vertically.\r\n * @return {Array}                Working layout.\r\n */\r\n/*\r\nexport function synchronizeLayoutWithChildren(initialLayout: Layout, children: Array<React.Element>|React.Element,\r\n                                              cols: number, verticalCompact: boolean): Layout {\r\n  // ensure 'children' is always an array\r\n  if (!Array.isArray(children)) {\r\n    children = [children];\r\n  }\r\n  initialLayout = initialLayout || [];\r\n\r\n  // Generate one layout item per child.\r\n  let layout: Layout = [];\r\n  for (let i = 0, len = children.length; i < len; i++) {\r\n    let newItem;\r\n    const child = children[i];\r\n\r\n    // Don't overwrite if it already exists.\r\n    const exists = getLayoutItem(initialLayout, child.key || \"1\" /!* FIXME satisfies Flow *!/);\r\n    if (exists) {\r\n      newItem = exists;\r\n    } else {\r\n      const g = child.props._grid;\r\n\r\n      // Hey, this item has a _grid property, use it.\r\n      if (g) {\r\n        if (!isProduction) {\r\n          validateLayout([g], 'ReactGridLayout.children');\r\n        }\r\n        // Validated; add it to the layout. Bottom 'y' possible is the bottom of the layout.\r\n        // This allows you to do nice stuff like specify {y: Infinity}\r\n        if (verticalCompact) {\r\n          newItem = cloneLayoutItem({...g, y: Math.min(bottom(layout), g.y), i: child.key});\r\n        } else {\r\n          newItem = cloneLayoutItem({...g, y: g.y, i: child.key});\r\n        }\r\n      }\r\n      // Nothing provided: ensure this is added to the bottom\r\n      else {\r\n        newItem = cloneLayoutItem({w: 1, h: 1, x: 0, y: bottom(layout), i: child.key || \"1\"});\r\n      }\r\n    }\r\n    layout[i] = newItem;\r\n  }\r\n\r\n  // Correct the layout.\r\n  layout = correctBounds(layout, {cols: cols});\r\n  layout = compact(layout, verticalCompact);\r\n\r\n  return layout;\r\n}\r\n*/\r\n\r\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\r\nexport function validateLayout(layout: Layout, contextName: string): void {\r\n  contextName = contextName || \"Layout\";\r\n  const subProps = ['x', 'y', 'w', 'h'];\r\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    const item = layout[i];\r\n    for (let j = 0; j < subProps.length; j++) {\r\n      if (typeof item[subProps[j]] !== 'number') {\r\n        throw new Error('VueGridLayout: ' + contextName + '[' + i + '].' + subProps[j] + ' must be a number!');\r\n      }\r\n    }\r\n    if (item.i && typeof item.i !== 'string') {\r\n      // number is also ok, so comment the error\r\n      // TODO confirm if commenting the line below doesn't cause unexpected problems\r\n      // throw new Error('VueGridLayout: ' + contextName + '[' + i + '].i must be a string!');\r\n    }\r\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\r\n      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].static must be a boolean!');\r\n    }\r\n  }\r\n}\r\n\r\n// Flow can't really figure this out, so we just use Object\r\nexport function autoBindHandlers(el: Object, fns: Array<string>): void {\r\n  fns.forEach((key) => el[key] = el[key].bind(el));\r\n}\r\n\r\n\r\n\r\n/**\r\n * Convert a JS object to CSS string. Similar to React's output of CSS.\r\n * @param obj\r\n * @returns {string}\r\n */\r\nexport function createMarkup(obj) {\r\n  var keys = Object.keys(obj);\r\n  if (!keys.length) return '';\r\n  var i, len = keys.length;\r\n  var result = '';\r\n\r\n  for (i = 0; i < len; i++) {\r\n    var key = keys[i];\r\n    var val = obj[key];\r\n    result += hyphenate(key) + ':' + addPx(key, val) + ';';\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n\r\n/* The following list is defined in React's core */\r\nexport var IS_UNITLESS = {\r\n  animationIterationCount: true,\r\n  boxFlex: true,\r\n  boxFlexGroup: true,\r\n  boxOrdinalGroup: true,\r\n  columnCount: true,\r\n  flex: true,\r\n  flexGrow: true,\r\n  flexPositive: true,\r\n  flexShrink: true,\r\n  flexNegative: true,\r\n  flexOrder: true,\r\n  gridRow: true,\r\n  gridColumn: true,\r\n  fontWeight: true,\r\n  lineClamp: true,\r\n  lineHeight: true,\r\n  opacity: true,\r\n  order: true,\r\n  orphans: true,\r\n  tabSize: true,\r\n  widows: true,\r\n  zIndex: true,\r\n  zoom: true,\r\n\r\n  // SVG-related properties\r\n  fillOpacity: true,\r\n  stopOpacity: true,\r\n  strokeDashoffset: true,\r\n  strokeOpacity: true,\r\n  strokeWidth: true\r\n};\r\n\r\n\r\n/**\r\n * Will add px to the end of style values which are Numbers.\r\n * @param name\r\n * @param value\r\n * @returns {*}\r\n */\r\nexport function addPx(name, value) {\r\n  if (typeof value === 'number' && !IS_UNITLESS[name]) {\r\n    return value + 'px';\r\n  } else {\r\n    return value;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Hyphenate a camelCase string.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n */\r\n\r\nexport var hyphenateRE = /([a-z\\d])([A-Z])/g;\r\n\r\nexport function hyphenate(str) {\r\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\r\n}\r\n\r\n\r\nexport function findItemInArray(array, property, value) {\r\n  for (var i = 0; i < array.length; i++)\r\n    if (array[i][property] == value)\r\n      return true;\r\n\r\n  return false;\r\n}\r\n\r\nexport function findAndRemove(array, property, value) {\r\n  array.forEach(function (result, index) {\r\n    if (result[property] === value) {\r\n      //Remove from array\r\n      array.splice(index, 1);\r\n    }\r\n  });\r\n}\r\n\r\n"]}]}