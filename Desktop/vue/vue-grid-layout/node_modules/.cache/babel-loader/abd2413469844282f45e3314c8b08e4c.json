{"remainingRequest":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\eslint-loader\\index.js??ref--13-0!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\helpers\\utils.js","dependencies":[{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\helpers\\utils.js","mtime":1618300880566},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.sort\";\n// @flow\n\n/*:: export type LayoutItemRequired = {w: number, h: number, x: number, y: number, i: string};*/\n\n/*:: export type LayoutItem = LayoutItemRequired &\r\n                         {minW?: number, minH?: number, maxW?: number, maxH?: number,\r\n                          moved?: boolean, static?: boolean,\r\n                          isDraggable?: ?boolean, isResizable?: ?boolean};*/\n\n// export type Position = {left: number, top: number, width: number, height: number};\n\n/*\r\nexport type DragCallbackData = {\r\n  node: HTMLElement,\r\n  x: number, y: number,\r\n  deltaX: number, deltaY: number,\r\n  lastX: number, lastY: number\r\n};\r\n*/\n// export type DragEvent = {e: Event} & DragCallbackData;\n\n/*:: export type Layout = Array<LayoutItem>;*/\n\n// export type ResizeEvent = {e: Event, node: HTMLElement, size: Size};\n// const isProduction = process.env.NODE_ENV === 'production';\n\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\n\n/*:: export type Size = {width: number, height: number};*/\n\nexport function bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\nexport function cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Fast path to cloning, since this is monomorphic\n\nexport function cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  /*return {\r\n    w: layoutItem.w, h: layoutItem.h, x: layoutItem.x, y: layoutItem.y, i: layoutItem.i,\r\n    minW: layoutItem.minW, maxW: layoutItem.maxW, minH: layoutItem.minH, maxH: layoutItem.maxH,\r\n    moved: Boolean(layoutItem.moved), static: Boolean(layoutItem.static),\r\n    // These can be null\r\n    isDraggable: layoutItem.isDraggable, isResizable: layoutItem.isResizable\r\n  };*/\n  return JSON.parse(JSON.stringify(layoutItem));\n}\n/**\r\n * Given two layoutitems, check if they collide.\r\n *\r\n * @return {Boolean}   True if colliding.\r\n */\n\nexport function collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1 === l2) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\n\nexport function compact(layout\n/*: Layout*/\n, verticalCompact\n/*: Boolean*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItemsByRowCol(layout); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = sorted[i]; // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, verticalCompact); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(l)] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n/**\r\n * Compact an item in the layout.\r\n */\n\nexport function compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, verticalCompact\n/*: boolean*/\n)\n/*: LayoutItem*/\n{\n  if (verticalCompact) {\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    l.y = collides.y + collides.h;\n  }\n\n  return l;\n}\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\n\nexport function correctBounds(layout\n/*: Layout*/\n, bounds\n/*: {cols: number}*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\n\nexport function getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\n\nexport function getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nexport function getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\n\nexport function getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  //return [];\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout Full layout to modify.\r\n * @param  {LayoutItem} l      element to move.\r\n * @param  {Number}     [x]    X position in grid units.\r\n * @param  {Number}     [y]    Y position in grid units.\r\n * @param  {Boolean}    [isUserAction] If true, designates that the item we're moving is\r\n *                                     being dragged/resized by th euser.\r\n */\n\nexport function moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: Number*/\n, y\n/*: Number*/\n, isUserAction\n/*: Boolean*/\n, preventCollision\n/*: Boolean*/\n)\n/*: Layout*/\n{\n  if (l.static) return layout; // Short-circuit if nothing to do.\n  //if (l.y === y && l.x === x) return layout;\n\n  var oldX = l.x;\n  var oldY = l.y;\n  var movingUp = y && l.y > y; // This is quite a bit faster than extending the object\n\n  if (typeof x === 'number') l.x = x;\n  if (typeof y === 'number') l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItemsByRowCol(layout);\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n\n  if (preventCollision && collisions.length) {\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i]; // console.log('resolving collision between', l.i, 'at', l.y, 'and', collision.i, 'at', collision.y);\n    // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // This makes it feel a bit more precise by waiting to swap for just a bit when moving up.\n\n    if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);\n    }\n  }\n\n  return layout;\n}\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n * @param  {Boolean} [isUserAction]  If true, designates that the item we're moving is being dragged/resized\r\n *                                   by the user.\r\n */\n\nexport function moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  var preventCollision = false; // we're already colliding\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: itemToMove.x,\n      y: itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: '-1'\n    };\n    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      return moveElement(layout, itemToMove, undefined, fakeItem.y, preventCollision);\n    }\n  } // Previously this was optimized to move below the collision directly, but this can cause problems\n  // with cascading moves, as an item may actually leapflog a collision and cause a reversal in order.\n\n\n  return moveElement(layout, itemToMove, undefined, itemToMove.y + 1, preventCollision);\n}\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\n\nexport function perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + '%';\n}\nexport function setTransform(top, left, width, height)\n/*: Object*/\n{\n  // Replace unitless items with px\n  var translate = \"translate3d(\" + left + \"px,\" + top + \"px, 0)\";\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n/**\r\n * Just like the setTransform method, but instead it will return a negative value of right.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{transform: string, WebkitTransform: string, MozTransform: string, msTransform: string, OTransform: string, width: string, height: string, position: string}}\r\n */\n\nexport function setTransformRtl(top, right, width, height)\n/*: Object*/\n{\n  // Replace unitless items with px\n  var translate = \"translate3d(\" + right * -1 + \"px,\" + top + \"px, 0)\";\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\nexport function setTopLeft(top, left, width, height)\n/*: Object*/\n{\n  return {\n    top: top + \"px\",\n    left: left + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n/**\r\n * Just like the setTopLeft method, but instead, it will return a right property instead of left.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{top: string, right: string, width: string, height: string, position: string}}\r\n */\n\nexport function setTopRight(top, right, width, height)\n/*: Object*/\n{\n  return {\n    top: top + \"px\",\n    right: right + \"px\",\n    width: width + \"px\",\n    height: height + \"px\",\n    position: 'absolute'\n  };\n}\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\n\nexport function sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return [].concat(layout).sort(function (a, b) {\n    if (a.y === b.y && a.x === b.x) {\n      return 0;\n    }\n\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\r\n * Generate a layout using the initialLayout and children as a template.\r\n * Missing entries will be added, extraneous ones will be truncated.\r\n *\r\n * @param  {Array}  initialLayout Layout passed in through props.\r\n * @param  {String} breakpoint    Current responsive breakpoint.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout vertically.\r\n * @return {Array}                Working layout.\r\n */\n\n/*\r\nexport function synchronizeLayoutWithChildren(initialLayout: Layout, children: Array<React.Element>|React.Element,\r\n                                              cols: number, verticalCompact: boolean): Layout {\r\n  // ensure 'children' is always an array\r\n  if (!Array.isArray(children)) {\r\n    children = [children];\r\n  }\r\n  initialLayout = initialLayout || [];\r\n\r\n  // Generate one layout item per child.\r\n  let layout: Layout = [];\r\n  for (let i = 0, len = children.length; i < len; i++) {\r\n    let newItem;\r\n    const child = children[i];\r\n\r\n    // Don't overwrite if it already exists.\r\n    const exists = getLayoutItem(initialLayout, child.key || \"1\" /!* FIXME satisfies Flow *!/);\r\n    if (exists) {\r\n      newItem = exists;\r\n    } else {\r\n      const g = child.props._grid;\r\n\r\n      // Hey, this item has a _grid property, use it.\r\n      if (g) {\r\n        if (!isProduction) {\r\n          validateLayout([g], 'ReactGridLayout.children');\r\n        }\r\n        // Validated; add it to the layout. Bottom 'y' possible is the bottom of the layout.\r\n        // This allows you to do nice stuff like specify {y: Infinity}\r\n        if (verticalCompact) {\r\n          newItem = cloneLayoutItem({...g, y: Math.min(bottom(layout), g.y), i: child.key});\r\n        } else {\r\n          newItem = cloneLayoutItem({...g, y: g.y, i: child.key});\r\n        }\r\n      }\r\n      // Nothing provided: ensure this is added to the bottom\r\n      else {\r\n        newItem = cloneLayoutItem({w: 1, h: 1, x: 0, y: bottom(layout), i: child.key || \"1\"});\r\n      }\r\n    }\r\n    layout[i] = newItem;\r\n  }\r\n\r\n  // Correct the layout.\r\n  layout = correctBounds(layout, {cols: cols});\r\n  layout = compact(layout, verticalCompact);\r\n\r\n  return layout;\r\n}\r\n*/\n\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\n\nexport function validateLayout(layout\n/*: Layout*/\n, contextName\n/*: string*/\n)\n/*: void*/\n{\n  contextName = contextName || \"Layout\";\n  var subProps = ['x', 'y', 'w', 'h'];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== 'number') {\n        throw new Error('VueGridLayout: ' + contextName + '[' + i + '].' + subProps[j] + ' must be a number!');\n      }\n    }\n\n    if (item.i && typeof item.i !== 'string') {// number is also ok, so comment the error\n      // TODO confirm if commenting the line below doesn't cause unexpected problems\n      // throw new Error('VueGridLayout: ' + contextName + '[' + i + '].i must be a string!');\n    }\n\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\n      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].static must be a boolean!');\n    }\n  }\n} // Flow can't really figure this out, so we just use Object\n\nexport function autoBindHandlers(el\n/*: Object*/\n, fns\n/*: Array<string>*/\n)\n/*: void*/\n{\n  fns.forEach(function (key) {\n    return el[key] = el[key].bind(el);\n  });\n}\n/**\r\n * Convert a JS object to CSS string. Similar to React's output of CSS.\r\n * @param obj\r\n * @returns {string}\r\n */\n\nexport function createMarkup(obj) {\n  var keys = Object.keys(obj);\n  if (!keys.length) return '';\n  var i,\n      len = keys.length;\n  var result = '';\n\n  for (i = 0; i < len; i++) {\n    var key = keys[i];\n    var val = obj[key];\n    result += hyphenate(key) + ':' + addPx(key, val) + ';';\n  }\n\n  return result;\n}\n/* The following list is defined in React's core */\n\nexport var IS_UNITLESS = {\n  animationIterationCount: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridColumn: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // SVG-related properties\n  fillOpacity: true,\n  stopOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n/**\r\n * Will add px to the end of style values which are Numbers.\r\n * @param name\r\n * @param value\r\n * @returns {*}\r\n */\n\nexport function addPx(name, value) {\n  if (typeof value === 'number' && !IS_UNITLESS[name]) {\n    return value + 'px';\n  } else {\n    return value;\n  }\n}\n/**\r\n * Hyphenate a camelCase string.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n */\n\nexport var hyphenateRE = /([a-z\\d])([A-Z])/g;\nexport function hyphenate(str) {\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n}\nexport function findItemInArray(array, property, value) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i][property] == value) return true;\n  }\n\n  return false;\n}\nexport function findAndRemove(array, property, value) {\n  array.forEach(function (result, index) {\n    if (result[property] === value) {\n      //Remove from array\n      array.splice(index, 1);\n    }\n  });\n}",{"version":3,"sources":["C:/Users/omar-/Desktop/vue/vue-grid-layout/src/helpers/utils.js"],"names":["bottom","layout","max","bottomY","i","len","length","y","h","cloneLayout","newLayout","Array","cloneLayoutItem","layoutItem","JSON","parse","stringify","collides","l1","l2","x","w","compact","verticalCompact","compareWith","getStatics","sorted","sortLayoutItemsByRowCol","out","l","static","compactItem","push","indexOf","moved","getFirstCollision","correctBounds","bounds","collidesWith","cols","getLayoutItem","id","getAllCollisions","filter","moveElement","isUserAction","preventCollision","oldX","oldY","movingUp","reverse","collisions","collision","moveElementAwayFromCollision","itemToMove","fakeItem","Math","undefined","perc","num","setTransform","top","left","width","height","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","setTransformRtl","right","setTopLeft","setTopRight","concat","sort","a","b","validateLayout","contextName","subProps","isArray","Error","item","j","autoBindHandlers","el","fns","forEach","key","bind","createMarkup","obj","keys","Object","result","val","hyphenate","addPx","IS_UNITLESS","animationIterationCount","boxFlex","boxFlexGroup","boxOrdinalGroup","columnCount","flex","flexGrow","flexPositive","flexShrink","flexNegative","flexOrder","gridRow","gridColumn","fontWeight","lineClamp","lineHeight","opacity","order","orphans","tabSize","widows","zIndex","zoom","fillOpacity","stopOpacity","strokeDashoffset","strokeOpacity","strokeWidth","name","value","hyphenateRE","str","replace","toLowerCase","findItemInArray","array","property","findAndRemove","index","splice"],"mappings":"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","sourcesContent":["// @flow\r\nexport type LayoutItemRequired = {w: number, h: number, x: number, y: number, i: string};\r\nexport type LayoutItem = LayoutItemRequired &\r\n                         {minW?: number, minH?: number, maxW?: number, maxH?: number,\r\n                          moved?: boolean, static?: boolean,\r\n                          isDraggable?: ?boolean, isResizable?: ?boolean};\r\nexport type Layout = Array<LayoutItem>;\r\n// export type Position = {left: number, top: number, width: number, height: number};\r\n/*\r\nexport type DragCallbackData = {\r\n  node: HTMLElement,\r\n  x: number, y: number,\r\n  deltaX: number, deltaY: number,\r\n  lastX: number, lastY: number\r\n};\r\n*/\r\n// export type DragEvent = {e: Event} & DragCallbackData;\r\nexport type Size = {width: number, height: number};\r\n// export type ResizeEvent = {e: Event, node: HTMLElement, size: Size};\r\n\r\n// const isProduction = process.env.NODE_ENV === 'production';\r\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\r\nexport function bottom(layout: Layout): number {\r\n  let max = 0, bottomY;\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    bottomY = layout[i]. y + layout[i].h;\r\n    if (bottomY > max) max = bottomY;\r\n  }\r\n  return max;\r\n}\r\n\r\nexport function cloneLayout(layout: Layout): Layout {\r\n  const newLayout = Array(layout.length);\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    newLayout[i] = cloneLayoutItem(layout[i]);\r\n  }\r\n  return newLayout;\r\n}\r\n\r\n// Fast path to cloning, since this is monomorphic\r\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\r\n  /*return {\r\n    w: layoutItem.w, h: layoutItem.h, x: layoutItem.x, y: layoutItem.y, i: layoutItem.i,\r\n    minW: layoutItem.minW, maxW: layoutItem.maxW, minH: layoutItem.minH, maxH: layoutItem.maxH,\r\n    moved: Boolean(layoutItem.moved), static: Boolean(layoutItem.static),\r\n    // These can be null\r\n    isDraggable: layoutItem.isDraggable, isResizable: layoutItem.isResizable\r\n  };*/\r\n    return JSON.parse(JSON.stringify(layoutItem));\r\n}\r\n\r\n/**\r\n * Given two layoutitems, check if they collide.\r\n *\r\n * @return {Boolean}   True if colliding.\r\n */\r\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\r\n  if (l1 === l2) return false; // same element\r\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\r\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\r\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\r\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\r\n  return true; // boxes overlap\r\n}\r\n\r\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\r\nexport function compact(layout: Layout, verticalCompact: Boolean): Layout {\r\n    // Statics go in the compareWith array right away so items flow around them.\r\n  const compareWith = getStatics(layout);\r\n  // We go through the items by row and column.\r\n  const sorted = sortLayoutItemsByRowCol(layout);\r\n  // Holding for new items.\r\n  const out = Array(layout.length);\r\n\r\n  for (let i = 0, len = sorted.length; i < len; i++) {\r\n    let l = sorted[i];\r\n\r\n    // Don't move static elements\r\n    if (!l.static) {\r\n      l = compactItem(compareWith, l, verticalCompact);\r\n\r\n      // Add to comparison array. We only collide with items before this one.\r\n      // Statics are already in this array.\r\n      compareWith.push(l);\r\n    }\r\n\r\n    // Add to output array to make sure they still come out in the right order.\r\n    out[layout.indexOf(l)] = l;\r\n\r\n    // Clear moved flag, if it exists.\r\n    l.moved = false;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Compact an item in the layout.\r\n */\r\nexport function compactItem(compareWith: Layout, l: LayoutItem, verticalCompact: boolean): LayoutItem {\r\n  if (verticalCompact) {\r\n    // Move the element up as far as it can go without colliding.\r\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\r\n      l.y--;\r\n    }\r\n  }\r\n\r\n  // Move it down, and keep moving it down if it's colliding.\r\n  let collides;\r\n  while((collides = getFirstCollision(compareWith, l))) {\r\n    l.y = collides.y + collides.h;\r\n  }\r\n  return l;\r\n}\r\n\r\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\r\nexport function correctBounds(layout: Layout, bounds: {cols: number}): Layout {\r\n  const collidesWith = getStatics(layout);\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    const l = layout[i];\r\n    // Overflows right\r\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\r\n    // Overflows left\r\n    if (l.x < 0) {\r\n      l.x = 0;\r\n      l.w = bounds.cols;\r\n    }\r\n    if (!l.static) collidesWith.push(l);\r\n    else {\r\n      // If this is static and collides with other statics, we must move it down.\r\n      // We have to do something nicer than just letting them overlap.\r\n      while(getFirstCollision(collidesWith, l)) {\r\n        l.y++;\r\n      }\r\n    }\r\n  }\r\n  return layout;\r\n}\r\n\r\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\r\nexport function getLayoutItem(layout: Layout, id: string): ?LayoutItem {\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    if (layout[i].i === id) return layout[i];\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\r\nexport function getFirstCollision(layout: Layout, layoutItem: LayoutItem): ?LayoutItem {\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    if (collides(layout[i], layoutItem)) return layout[i];\r\n  }\r\n}\r\n\r\nexport function getAllCollisions(layout: Layout, layoutItem: LayoutItem): Array<LayoutItem> {\r\n  return layout.filter((l) => collides(l, layoutItem));\r\n}\r\n\r\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\r\nexport function getStatics(layout: Layout): Array<LayoutItem> {\r\n    //return [];\r\n    return layout.filter((l) => l.static);\r\n}\r\n\r\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout Full layout to modify.\r\n * @param  {LayoutItem} l      element to move.\r\n * @param  {Number}     [x]    X position in grid units.\r\n * @param  {Number}     [y]    Y position in grid units.\r\n * @param  {Boolean}    [isUserAction] If true, designates that the item we're moving is\r\n *                                     being dragged/resized by th euser.\r\n */\r\nexport function moveElement(layout: Layout, l: LayoutItem, x: Number, y: Number, isUserAction: Boolean, preventCollision: Boolean): Layout {\r\n  if (l.static) return layout;\r\n\r\n  // Short-circuit if nothing to do.\r\n  //if (l.y === y && l.x === x) return layout;\r\n\r\n  const oldX = l.x;\r\n  const oldY = l.y;\r\n\r\n  const movingUp = y && l.y > y;\r\n  // This is quite a bit faster than extending the object\r\n  if (typeof x === 'number') l.x = x;\r\n  if (typeof y === 'number') l.y = y;\r\n  l.moved = true;\r\n\r\n  // If this collides with anything, move it.\r\n  // When doing this comparison, we have to sort the items we compare with\r\n  // to ensure, in the case of multiple collisions, that we're getting the\r\n  // nearest collision.\r\n  let sorted = sortLayoutItemsByRowCol(layout);\r\n  if (movingUp) sorted = sorted.reverse();\r\n  const collisions = getAllCollisions(sorted, l);\r\n\r\n  if (preventCollision && collisions.length) {\r\n    l.x = oldX;\r\n    l.y = oldY;\r\n    l.moved = false;\r\n    return layout;\r\n  }\r\n\r\n  // Move each item that collides away from this element.\r\n  for (let i = 0, len = collisions.length; i < len; i++) {\r\n    const collision = collisions[i];\r\n    // console.log('resolving collision between', l.i, 'at', l.y, 'and', collision.i, 'at', collision.y);\r\n\r\n    // Short circuit so we can't infinite loop\r\n    if (collision.moved) continue;\r\n\r\n    // This makes it feel a bit more precise by waiting to swap for just a bit when moving up.\r\n    if (l.y > collision.y && l.y - collision.y > collision.h / 4) continue;\r\n\r\n    // Don't move static items - we have to move *this* element away\r\n    if (collision.static) {\r\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction);\r\n    } else {\r\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction);\r\n    }\r\n  }\r\n\r\n  return layout;\r\n}\r\n\r\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n * @param  {Boolean} [isUserAction]  If true, designates that the item we're moving is being dragged/resized\r\n *                                   by the user.\r\n */\r\nexport function moveElementAwayFromCollision(layout: Layout, collidesWith: LayoutItem,\r\n                                             itemToMove: LayoutItem, isUserAction: ?boolean): Layout {\r\n\r\n  const preventCollision = false // we're already colliding\r\n  // If there is enough space above the collision to put this element, move it there.\r\n  // We only do this on the main collision as this can get funky in cascades and cause\r\n  // unwanted swapping behavior.\r\n  if (isUserAction) {\r\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\r\n    const fakeItem: LayoutItem = {\r\n      x: itemToMove.x,\r\n      y: itemToMove.y,\r\n      w: itemToMove.w,\r\n      h: itemToMove.h,\r\n      i: '-1'\r\n    };\r\n    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0);\r\n    if (!getFirstCollision(layout, fakeItem)) {\r\n      return moveElement(layout, itemToMove, undefined, fakeItem.y, preventCollision);\r\n    }\r\n  }\r\n\r\n  // Previously this was optimized to move below the collision directly, but this can cause problems\r\n  // with cascading moves, as an item may actually leapflog a collision and cause a reversal in order.\r\n  return moveElement(layout, itemToMove, undefined, itemToMove.y + 1, preventCollision);\r\n}\r\n\r\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\r\nexport function perc(num: number): string {\r\n  return num * 100 + '%';\r\n}\r\n\r\nexport function setTransform(top, left, width, height): Object {\r\n  // Replace unitless items with px\r\n  const translate = \"translate3d(\" + left + \"px,\" + top + \"px, 0)\";\r\n  return {\r\n    transform: translate,\r\n    WebkitTransform: translate,\r\n    MozTransform: translate,\r\n    msTransform: translate,\r\n    OTransform: translate,\r\n    width: width + \"px\",\r\n    height: height + \"px\",\r\n    position: 'absolute'\r\n  };\r\n}\r\n/**\r\n * Just like the setTransform method, but instead it will return a negative value of right.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{transform: string, WebkitTransform: string, MozTransform: string, msTransform: string, OTransform: string, width: string, height: string, position: string}}\r\n */\r\nexport function setTransformRtl(top, right, width, height): Object {\r\n    // Replace unitless items with px\r\n    const translate = \"translate3d(\" + right * -1 + \"px,\" + top + \"px, 0)\";\r\n    return {\r\n        transform: translate,\r\n        WebkitTransform: translate,\r\n        MozTransform: translate,\r\n        msTransform: translate,\r\n        OTransform: translate,\r\n        width: width + \"px\",\r\n        height: height + \"px\",\r\n        position: 'absolute'\r\n    };\r\n}\r\n\r\nexport function setTopLeft(top, left, width, height): Object {\r\n    return {\r\n        top: top + \"px\",\r\n        left: left + \"px\",\r\n        width: width + \"px\",\r\n        height: height + \"px\",\r\n        position: 'absolute'\r\n    };\r\n}\r\n/**\r\n * Just like the setTopLeft method, but instead, it will return a right property instead of left.\r\n *\r\n * @param top\r\n * @param right\r\n * @param width\r\n * @param height\r\n * @returns {{top: string, right: string, width: string, height: string, position: string}}\r\n */\r\nexport function setTopRight(top, right, width, height): Object {\r\n    return {\r\n        top: top + \"px\",\r\n        right: right+ \"px\",\r\n        width: width + \"px\",\r\n        height: height + \"px\",\r\n        position: 'absolute'\r\n    };\r\n}\r\n\r\n\r\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\r\nexport function sortLayoutItemsByRowCol(layout: Layout): Layout {\r\n  return [].concat(layout).sort(function(a, b) {\r\n    if (a.y === b.y && a.x === b.x) {\r\n      return 0;\r\n    }\r\n\r\n    if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\r\n      return 1;\r\n    }\r\n\r\n    return -1;\r\n  });\r\n}\r\n\r\n/**\r\n * Generate a layout using the initialLayout and children as a template.\r\n * Missing entries will be added, extraneous ones will be truncated.\r\n *\r\n * @param  {Array}  initialLayout Layout passed in through props.\r\n * @param  {String} breakpoint    Current responsive breakpoint.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout vertically.\r\n * @return {Array}                Working layout.\r\n */\r\n/*\r\nexport function synchronizeLayoutWithChildren(initialLayout: Layout, children: Array<React.Element>|React.Element,\r\n                                              cols: number, verticalCompact: boolean): Layout {\r\n  // ensure 'children' is always an array\r\n  if (!Array.isArray(children)) {\r\n    children = [children];\r\n  }\r\n  initialLayout = initialLayout || [];\r\n\r\n  // Generate one layout item per child.\r\n  let layout: Layout = [];\r\n  for (let i = 0, len = children.length; i < len; i++) {\r\n    let newItem;\r\n    const child = children[i];\r\n\r\n    // Don't overwrite if it already exists.\r\n    const exists = getLayoutItem(initialLayout, child.key || \"1\" /!* FIXME satisfies Flow *!/);\r\n    if (exists) {\r\n      newItem = exists;\r\n    } else {\r\n      const g = child.props._grid;\r\n\r\n      // Hey, this item has a _grid property, use it.\r\n      if (g) {\r\n        if (!isProduction) {\r\n          validateLayout([g], 'ReactGridLayout.children');\r\n        }\r\n        // Validated; add it to the layout. Bottom 'y' possible is the bottom of the layout.\r\n        // This allows you to do nice stuff like specify {y: Infinity}\r\n        if (verticalCompact) {\r\n          newItem = cloneLayoutItem({...g, y: Math.min(bottom(layout), g.y), i: child.key});\r\n        } else {\r\n          newItem = cloneLayoutItem({...g, y: g.y, i: child.key});\r\n        }\r\n      }\r\n      // Nothing provided: ensure this is added to the bottom\r\n      else {\r\n        newItem = cloneLayoutItem({w: 1, h: 1, x: 0, y: bottom(layout), i: child.key || \"1\"});\r\n      }\r\n    }\r\n    layout[i] = newItem;\r\n  }\r\n\r\n  // Correct the layout.\r\n  layout = correctBounds(layout, {cols: cols});\r\n  layout = compact(layout, verticalCompact);\r\n\r\n  return layout;\r\n}\r\n*/\r\n\r\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\r\nexport function validateLayout(layout: Layout, contextName: string): void {\r\n  contextName = contextName || \"Layout\";\r\n  const subProps = ['x', 'y', 'w', 'h'];\r\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    const item = layout[i];\r\n    for (let j = 0; j < subProps.length; j++) {\r\n      if (typeof item[subProps[j]] !== 'number') {\r\n        throw new Error('VueGridLayout: ' + contextName + '[' + i + '].' + subProps[j] + ' must be a number!');\r\n      }\r\n    }\r\n    if (item.i && typeof item.i !== 'string') {\r\n      // number is also ok, so comment the error\r\n        // TODO confirm if commenting the line below doesn't cause unexpected problems\r\n      // throw new Error('VueGridLayout: ' + contextName + '[' + i + '].i must be a string!');\r\n    }\r\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\r\n      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].static must be a boolean!');\r\n    }\r\n  }\r\n}\r\n\r\n// Flow can't really figure this out, so we just use Object\r\nexport function autoBindHandlers(el: Object, fns: Array<string>): void {\r\n  fns.forEach((key) => el[key] = el[key].bind(el));\r\n}\r\n\r\n\r\n\r\n/**\r\n * Convert a JS object to CSS string. Similar to React's output of CSS.\r\n * @param obj\r\n * @returns {string}\r\n */\r\nexport function createMarkup(obj) {\r\n    var keys = Object.keys(obj);\r\n    if (!keys.length) return '';\r\n    var i, len = keys.length;\r\n    var result = '';\r\n\r\n    for (i = 0; i < len; i++) {\r\n        var key = keys[i];\r\n        var val = obj[key];\r\n        result += hyphenate(key) + ':' + addPx(key, val) + ';';\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n\r\n/* The following list is defined in React's core */\r\nexport var IS_UNITLESS = {\r\n    animationIterationCount: true,\r\n    boxFlex: true,\r\n    boxFlexGroup: true,\r\n    boxOrdinalGroup: true,\r\n    columnCount: true,\r\n    flex: true,\r\n    flexGrow: true,\r\n    flexPositive: true,\r\n    flexShrink: true,\r\n    flexNegative: true,\r\n    flexOrder: true,\r\n    gridRow: true,\r\n    gridColumn: true,\r\n    fontWeight: true,\r\n    lineClamp: true,\r\n    lineHeight: true,\r\n    opacity: true,\r\n    order: true,\r\n    orphans: true,\r\n    tabSize: true,\r\n    widows: true,\r\n    zIndex: true,\r\n    zoom: true,\r\n\r\n    // SVG-related properties\r\n    fillOpacity: true,\r\n    stopOpacity: true,\r\n    strokeDashoffset: true,\r\n    strokeOpacity: true,\r\n    strokeWidth: true\r\n};\r\n\r\n\r\n/**\r\n * Will add px to the end of style values which are Numbers.\r\n * @param name\r\n * @param value\r\n * @returns {*}\r\n */\r\nexport function addPx(name, value) {\r\n    if(typeof value === 'number' && !IS_UNITLESS[ name ]) {\r\n        return value + 'px';\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Hyphenate a camelCase string.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n */\r\n\r\nexport var hyphenateRE = /([a-z\\d])([A-Z])/g;\r\n\r\nexport function hyphenate(str) {\r\n    return str.replace(hyphenateRE, '$1-$2').toLowerCase();\r\n}\r\n\r\n\r\nexport function findItemInArray(array, property, value) {\r\n    for (var i=0; i < array.length; i++)\r\n        if (array[i][property] == value)\r\n            return true;\r\n\r\n    return false;\r\n}\r\n\r\nexport function findAndRemove(array, property, value) {\r\n    array.forEach(function (result, index) {\r\n        if (result[property] === value) {\r\n            //Remove from array\r\n            array.splice(index, 1);\r\n        }\r\n    });\r\n}\r\n"]}]}