{"remainingRequest":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\eslint-loader\\index.js??ref--13-0!C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\helpers\\responsiveUtils.js","dependencies":[{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\src\\helpers\\responsiveUtils.js","mtime":1610648031000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\Users\\omar-\\Desktop\\vue\\vue-grid-layout\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\n// @flow\nimport { cloneLayout, compact, correctBounds } from \"./utils\";\n\n/*:: import type {Layout} from './utils';*/\n\n/*:: export type ResponsiveLayout = {lg?: Layout, md?: Layout, sm?: Layout, xs?: Layout, xxs?: Layout};*/\n\n/*:: type Breakpoint = string;*/\n\n/**\r\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\r\n *\r\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\r\n * @param  {Number} width Screen width.\r\n * @return {String}       Highest breakpoint that is less than width.\r\n */\n\n/*:: type Breakpoints = {lg?: number, md?: number, sm?: number, xs?: number, xxs?: number};*/\n\nexport function getBreakpointFromWidth(breakpoints\n/*: Breakpoints*/\n, width\n/*: number*/\n)\n/*: Breakpoint*/\n{\n  var sorted = sortBreakpoints(breakpoints);\n  var matching = sorted[0];\n\n  for (var i = 1, len = sorted.length; i < len; i++) {\n    var breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n\n  return matching;\n}\n/**\r\n * Given a breakpoint, get the # of cols set for it.\r\n * @param  {String} breakpoint Breakpoint name.\r\n * @param  {Object} cols       Map of breakpoints to cols.\r\n * @return {Number}            Number of cols.\r\n */\n\nexport function getColsFromBreakpoint(breakpoint\n/*: Breakpoint*/\n, cols\n/*: Breakpoints*/\n)\n/*: number*/\n{\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n\n  return cols[breakpoint];\n}\n/**\r\n * Given existing layouts and a new breakpoint, find or generate a new layout.\r\n *\r\n * This finds the layout above the new one and generates from it, if it exists.\r\n *\r\n * @param  {Array} orgLayout     Original layout.\r\n * @param  {Object} layouts     Existing layouts.\r\n * @param  {Array} breakpoints All breakpoints.\r\n * @param  {String} breakpoint New breakpoint.\r\n * @param  {String} breakpoint Last breakpoint (for fallback).\r\n * @param  {Number} cols       Column count at new breakpoint.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}             New layout.\r\n */\n\nexport function findOrGenerateResponsiveLayout(orgLayout\n/*: Layout*/\n, layouts\n/*: ResponsiveLayout*/\n, breakpoints\n/*: Breakpoints*/\n, breakpoint\n/*: Breakpoint*/\n, lastBreakpoint\n/*: Breakpoint*/\n, cols\n/*: number*/\n, verticalCompact\n/*: boolean*/\n)\n/*: Layout*/\n{\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]); // Find or generate the next layout\n\n  var layout = orgLayout;\n  var breakpointsSorted = sortBreakpoints(breakpoints);\n  var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n\n  for (var i = 0, len = breakpointsAbove.length; i < len; i++) {\n    var b = breakpointsAbove[i];\n\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n\n  layout = cloneLayout(layout || []); // clone layout so we don't modify existing items\n\n  return compact(correctBounds(layout, {\n    cols: cols\n  }), verticalCompact);\n}\nexport function generateResponsiveLayout(layout\n/*: Layout*/\n, breakpoints\n/*: Breakpoints*/\n, breakpoint\n/*: Breakpoint*/\n, lastBreakpoint\n/*: Breakpoint*/\n, cols\n/*: number*/\n, verticalCompact\n/*: boolean*/\n)\n/*: Layout*/\n{\n  // If it already exists, just return it.\n\n  /*if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]);\r\n  // Find or generate the next layout\r\n  let layout = layouts[lastBreakpoint];*/\n\n  /*const breakpointsSorted = sortBreakpoints(breakpoints);\r\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\r\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\r\n  const b = breakpointsAbove[i];\r\n  if (layouts[b]) {\r\n    layout = layouts[b];\r\n    break;\r\n  }\r\n  }*/\n  layout = cloneLayout(layout || []); // clone layout so we don't modify existing items\n\n  return compact(correctBounds(layout, {\n    cols: cols\n  }), verticalCompact);\n}\n/**\r\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\r\n * e.g. ['xxs', 'xs', 'sm', ...]\r\n *\r\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\r\n * @return {Array}              Sorted breakpoints.\r\n */\n\nexport function sortBreakpoints(breakpoints\n/*: Breakpoints*/\n)\n/*: Array<Breakpoint>*/\n{\n  var keys\n  /*: Array<string>*/\n  = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}",{"version":3,"sources":["C:/Users/omar-/Desktop/vue/vue-grid-layout/src/helpers/responsiveUtils.js"],"names":["cloneLayout","compact","correctBounds","getBreakpointFromWidth","breakpoints","width","sorted","sortBreakpoints","matching","i","len","length","breakpointName","getColsFromBreakpoint","breakpoint","cols","Error","findOrGenerateResponsiveLayout","orgLayout","layouts","lastBreakpoint","verticalCompact","layout","breakpointsSorted","breakpointsAbove","slice","indexOf","b","generateResponsiveLayout","keys","Object","sort","a"],"mappings":"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","sourcesContent":["// @flow\r\n\r\nimport {cloneLayout, compact, correctBounds} from './utils';\r\n\r\nimport type {Layout} from './utils';\r\nexport type ResponsiveLayout = {lg?: Layout, md?: Layout, sm?: Layout, xs?: Layout, xxs?: Layout};\r\ntype Breakpoint = string;\r\ntype Breakpoints = {lg?: number, md?: number, sm?: number, xs?: number, xxs?: number};\r\n\r\n/**\r\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\r\n *\r\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\r\n * @param  {Number} width Screen width.\r\n * @return {String}       Highest breakpoint that is less than width.\r\n */\r\nexport function getBreakpointFromWidth(breakpoints: Breakpoints, width: number): Breakpoint {\r\n  const sorted = sortBreakpoints(breakpoints);\r\n  let matching = sorted[0];\r\n  for (let i = 1, len = sorted.length; i < len; i++) {\r\n    const breakpointName = sorted[i];\r\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\r\n  }\r\n  return matching;\r\n}\r\n\r\n\r\n/**\r\n * Given a breakpoint, get the # of cols set for it.\r\n * @param  {String} breakpoint Breakpoint name.\r\n * @param  {Object} cols       Map of breakpoints to cols.\r\n * @return {Number}            Number of cols.\r\n */\r\nexport function getColsFromBreakpoint(breakpoint: Breakpoint, cols: Breakpoints): number {\r\n  if (!cols[breakpoint]) {\r\n    throw new Error(\"ResponsiveGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\r\n  }\r\n  return cols[breakpoint];\r\n}\r\n\r\n/**\r\n * Given existing layouts and a new breakpoint, find or generate a new layout.\r\n *\r\n * This finds the layout above the new one and generates from it, if it exists.\r\n *\r\n * @param  {Array} orgLayout     Original layout.\r\n * @param  {Object} layouts     Existing layouts.\r\n * @param  {Array} breakpoints All breakpoints.\r\n * @param  {String} breakpoint New breakpoint.\r\n * @param  {String} breakpoint Last breakpoint (for fallback).\r\n * @param  {Number} cols       Column count at new breakpoint.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}             New layout.\r\n */\r\nexport function findOrGenerateResponsiveLayout(orgLayout: Layout, layouts: ResponsiveLayout, breakpoints: Breakpoints,\r\n                                               breakpoint: Breakpoint, lastBreakpoint: Breakpoint,\r\n                                               cols: number, verticalCompact: boolean): Layout {\r\n  // If it already exists, just return it.\r\n  if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]);\r\n  // Find or generate the next layout\r\n  let layout = orgLayout;\r\n\r\n  const breakpointsSorted = sortBreakpoints(breakpoints);\r\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\r\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\r\n    const b = breakpointsAbove[i];\r\n    if (layouts[b]) {\r\n      layout = layouts[b];\r\n      break;\r\n    }\r\n  }\r\n  layout = cloneLayout(layout || []); // clone layout so we don't modify existing items\r\n  return compact(correctBounds(layout, {cols: cols}), verticalCompact);\r\n}\r\n\r\nexport function generateResponsiveLayout(layout: Layout, breakpoints: Breakpoints,\r\n                                               breakpoint: Breakpoint, lastBreakpoint: Breakpoint,\r\n                                               cols: number, verticalCompact: boolean): Layout {\r\n  // If it already exists, just return it.\r\n  /*if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]);\r\n  // Find or generate the next layout\r\n  let layout = layouts[lastBreakpoint];*/\r\n    /*const breakpointsSorted = sortBreakpoints(breakpoints);\r\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\r\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\r\n    const b = breakpointsAbove[i];\r\n    if (layouts[b]) {\r\n      layout = layouts[b];\r\n      break;\r\n    }\r\n  }*/\r\n  layout = cloneLayout(layout || []); // clone layout so we don't modify existing items\r\n  return compact(correctBounds(layout, {cols: cols}), verticalCompact);\r\n}\r\n\r\n/**\r\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\r\n * e.g. ['xxs', 'xs', 'sm', ...]\r\n *\r\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\r\n * @return {Array}              Sorted breakpoints.\r\n */\r\nexport function sortBreakpoints(breakpoints: Breakpoints): Array<Breakpoint> {\r\n  const keys: Array<string> = Object.keys(breakpoints);\r\n  return keys.sort(function(a, b) {\r\n    return breakpoints[a] - breakpoints[b];\r\n  });\r\n}\r\n"]}]}